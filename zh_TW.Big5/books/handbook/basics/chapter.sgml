<!--
     The FreeBSD Traditional Chinese Documentation Project

     $FreeBSD$
     Original revision: 1.158
-->

<chapter id="basics">
  <chapterinfo>
    <authorgroup>
      <author>
        <firstname>Chris</firstname>
	<surname>Shumway</surname>
	<contrib>Rewritten by </contrib>
      </author>
    </authorgroup>
    <!-- 10 Mar 2000 -->
  </chapterinfo>

  <title>UNIX 基礎概念</title>
 
  <sect1 id="basics-synopsis">
    <title>概述</title>

    <para>以下章節將涵蓋 FreeBSD 作業系統的基本指令及功能。
      大部份的內容在 &unix;-like 作業系統中都是相通的。
      如果您對這些內容熟悉的話，可以放心跳過。
      若您剛接觸 FreeBSD，那一定要仔細讀完這章。</para>

    <para>讀完這章，您將了解：</para>

    <itemizedlist>
      <listitem>
        <para>如何使用 FreeBSD 的<quote>virtual consoles</quote>。</para>
      </listitem>
      <listitem>
	<para>&unix; 檔案權限運作的方式以及 &os; 中檔案的 flags。</para>
      </listitem>
      <listitem>
	<para>預設的 &os; 檔案系統配置。</para>
      </listitem>
      <listitem>
	<para>&os; 的磁碟結構。</para>
      </listitem>
      <listitem>
	<para>如何掛載(mount)、卸載(umount)檔案系統</para>
      </listitem>
      <listitem>
	<para>什麼是processes、daemons 以及 signals 。</para>
      </listitem>
      <listitem>
	<para>什麼是 shell ，以及如何變更您預設的登入環境。</para>
      </listitem>
      <listitem>
	<para>如何使用基本的文字編輯器。</para>
      </listitem>
      <listitem>
	<para>什麼是 devices 和 device nodes 。</para>
      </listitem>
      <listitem>
	<para>&os; 下使用的 binary 格式。</para>
      </listitem>
      <listitem>
	<para>如何閱讀 manual pages 以獲得更多的資訊。</para>
      </listitem>
    </itemizedlist>

  </sect1>

  <sect1 id="consoles">
    <title>Virtual Consoles 和終端機</title>
    <indexterm><primary>virtual consoles</primary></indexterm>
    <indexterm><primary>terminals</primary></indexterm>

    <para>有很多方法可以操作 FreeBSD ，其中一種就是在文字終端機上打字。
      如此使用 FreeBSD 即可輕易的體會到 &unix; 作業系統的威力和彈性。
      這一節描述什麼是<quote>終端機</quote>和 <quote>console</quote>
      ，以及在 FreeBSD 中能夠如何運用。</para>

    <sect2 id="consoles-intro">
      <title>The Console</title>
      <indexterm><primary>console</primary></indexterm>

      <para>如果您沒有設定 FreeBSD 開機時要自動進入圖形化環境，系統會在啟動的
	script 跑完之後顯示登入的提示，您會看到像這樣：</para>

      <screen>Additional ABI support:.
Local package initialization:.
Additional TCP options:.

Fri Sep 20 13:01:06 EEST 2002

FreeBSD/i386 (pc3.example.org) (ttyv0)

login:</screen>

      <para>您的系統出現的訊息可能略有不同，但應該會看到類似的東西。
	    我們有興趣的是最後兩行，倒數第二行是：</para>

      <programlisting>FreeBSD/i386 (pc3.example.org) (ttyv0)</programlisting>

      <para>這行包含了剛開機完系統的資訊。您看到的是在 Intel 或相容處理器的
	x86 架構上執行的 <quote>FreeBSD</quote>的 console<footnote>
          <para>這就是 <literal>i386</literal> 的意義。 注意即使您不是在
	    Intel 的 386 處理器上執行 FreeBSD ，一樣是 <literal>i386</literal>。
            這裡顯示的並非您的處理器型號，而是您的處理器<quote>架構</quote>
	    </para>
        </footnote>。這台機器的名字（每台 &unix; 機器都有一個名字）是 
        <hostid>pc3.example.org</hostid>，而您正看著它的系統 
        console&mdash; <devicename>ttyv0</devicename>終端機。</para>

      <para>最後一行都會是：</para>

      <programlisting>login:</programlisting>

      <para>要在此處要輸入您的<quote>使用者名稱</quote>，才能登入
	FreeBSD ，下一小節將會說明步驟。</para>
    </sect2>

    <sect2 id="consoles-login">
      <title>登入 FreeBSD</title>

      <para>FreeBSD 是一個多人共用 (multiuser)、多工 (multiprocessing) 的系統。
	這是一個正式的名稱，指的是在單一機器上可以讓許多人使用，且他們
	同時可以執行大量程式的系統。</para>

      <para>每個多人共用系統都需要有分辨不同<quote>使用者</quote>的方法。
        在 FreeBSD（以及所有的 &unix;-like 作業系統）中，
	作法就是每位使用者必須<quote>登入</quote>系統才能執行程式。
	每位使用者有獨特的使用者名稱
        (<quote>username</quote>) 及密碼 (<quote>password</quote>)，
        FreeBSD 會先問這兩樣東西，才允許使用者執行任何程式。</para>

      <indexterm><primary>startup scripts</primary></indexterm>
      <para>在 FreeBSD 開機並執行完啟動的 script 之後<footnote>
        <para>這些啟動的 script 是開機時 FreeBSD 會自動執行的程式。
	  他們主要功能是設定好將所有其他該執行的東西，
	  並啟動您已設定成背景執行的服務。</para>
      </footnote>，它將會印出提示要求您輸入正確的使用者名稱：</para>

      <screen>login:</screen>

      <para>在這個範例裡，我們假設您的使用者名稱為是<username>john</username>。
        在提示處輸入 <literal>john</literal> 並按下 <keycap>Enter</keycap>。
	接著您應該會看到要您輸入<quote>密碼</quote>的提示：</para>

      <screen>login: <userinput>john</userinput>
Password:</screen>

      <para>現在輸入 <username>john</username> 的密碼，再按下
	<keycap>Enter</keycap>。輸入的密碼
	<emphasis>完全不會顯示！</emphasis>
	您不用擔心，這樣做是安全上的考量。</para>

      <para>如果打了正確的密碼，您現在應該已經登入 FreeBSD，
	可以去嘗試所有可用的指令了。</para>

      <para>您應該會看到 <acronym>MOTD</acronym>
        ——今日訊息 (messages of the day) ——後面接著命令提示字元
        （<literal>#</literal>,<literal>$</literal> 或是
	<literal>%</literal>）。 這就表示您已經成功登入
	FreeBSD 了。</para>
    </sect2>

    <sect2 id="consoles-virtual">
      <title>多重 Console</title>

      <para>在一個 console 下執行 &unix; 指令當然不錯，然而 FreeBSD
	可以同時執行很多程式。像 FreeBSD
	這樣可以同時執行一大堆程式的作業系統，只有一個
        console 可以輸入指令實在有點浪費，因此
	<quote>virtual consoles</quote> 就顯得相當好用。</para>

      <para>可以設定讓 FreeBSD 同時有很多 virtual console，
	用幾個按鍵的組合就可以從一個 virtual console 跳到別的 virtual console
	。每個 console 都有自己不同的輸出頻道，當從某個 virtual console
	切換到下一個時，FreeBSD 會自動處理鍵盤輸入及顯示器輸出。</para>
          
      <para>FreeBSD 保留了特別的按鍵組合來切換 console <footnote>
        <para>在 &man.syscons.4;、&man.atkbd.4;、&man.vidcontrol.1;、 &man.kbdcontrol.1;
	  等 manual page 中，對於 FreeBSD 的 console
          及鍵盤驅動程式有詳細的技術說明。我們在這裡不討論細節，
	  有興趣的讀者隨時可以在 manual page
	  中查到關於運作方式的更詳盡的解釋。</para></footnote>。
	您可以用 <keycombo><keycap>Alt</keycap><keycap>F1</keycap></keycombo>、
        <keycombo><keycap>Alt</keycap><keycap>F2</keycap></keycombo>，一直到
        <keycombo><keycap>Alt</keycap><keycap>F8</keycap></keycombo>
	來切換 FreeBSD 的不同 console。</para>
    
      <para>當您從一個 console 切換到下一個的時候，FreeBSD 
	會處理螢幕輸出的儲存及回復。
	這就<quote>好像</quote>有很多<quote>虛擬</quote>的螢幕和鍵盤，
	可以讓您輸入指令到 FreeBSD 執行。在某個虛擬 console
	上執行的程式並不會因為切到別的 console 而停止執行，切換到另一個虛擬
	console 時，它們仍會繼續執行。</para>
    </sect2>

    <sect2 id="consoles-ttys">
      <title><filename>/etc/ttys</filename> 檔</title>

      <para>FreeBSD 預設的虛擬 console 總共有 8 個，
        但這並非硬性規定，您可輕易自訂開機時啟動的虛擬 console 數量多寡。
	有關虛擬 console 的編號跟設定都在
	<filename>/etc/ttys</filename> 這檔案內設定。</para>

      <para>可以用 <filename>/etc/ttys</filename> 檔案來設定
	FreeBSD 的虛擬 console。 檔案內每行非註解文字（該行開頭沒有
	<literal>#</literal> 字號）都是設定單一終端機或虛擬 console。
	FreeBSD 預設有 9 個虛擬 console 但只啟動 8 個，也就是以下
	<literal>ttyv</literal>	開頭的那幾行設定：</para>

      <programlisting># name  getty                           type    status          comments
#
ttyv0   "/usr/libexec/getty Pc"         cons25  on  secure
# Virtual terminals
ttyv1   "/usr/libexec/getty Pc"         cons25  on  secure
ttyv2   "/usr/libexec/getty Pc"         cons25  on  secure
ttyv3   "/usr/libexec/getty Pc"         cons25  on  secure
ttyv4   "/usr/libexec/getty Pc"         cons25  on  secure
ttyv5   "/usr/libexec/getty Pc"         cons25  on  secure
ttyv6   "/usr/libexec/getty Pc"         cons25  on  secure
ttyv7   "/usr/libexec/getty Pc"         cons25  on  secure
ttyv8   "/usr/X11R6/bin/xdm -nodaemon"  xterm   off secure</programlisting>

      <para>有關檔案內各欄位的詳細介紹及所有設定虛擬 console 的選項，請參閱 &man.ttys.5;
	manual page。</para>
    </sect2>

    <sect2 id="consoles-singleuser">
      <title>Single User 模式的 Console</title>

      <para><quote>single user 模式</quote> 在 
	<xref linkend="boot-singleuser">
        有詳盡介紹。FreeBSD 在 single user 模式時只能使用一個 console，
	並無虛擬 console 可用。Single user 模式的 console 也能在
	<filename>/etc/ttys</filename> 檔設定，找
	<literal>console</literal> 開頭的那行：</para>

      <programlisting># name  getty                           type    status          comments
#
# If console is marked "insecure", then init will ask for the root password
# when going to single-user mode.
console none                            unknown off secure</programlisting>

      <note>
	<para>在 <literal>console</literal> 那行前面的註解有提到，可以把那行的
	  <literal>secure</literal> 改為 <literal>insecure</literal>，
	  如此一來，即使 FreeBSD 進入 single user 模式，
	  仍會要求輸入 <username>root</username> 的密碼。</para>

	<para><emphasis>請慎重考慮是否要改為
	  <literal>insecure</literal></emphasis>。一旦忘記
	  <username>root</username> 密碼，要登入 single user
	  模式就有些麻煩了。儘管還有其他方式可以登入，但對不熟 FreeBSD
	  開機程序的人而言，就會相當棘手。</para>
      </note>
    </sect2>

    <sect2 id="consoles-vidcontrol">
      <title>更改 console 的顯示畫面</title>

      <para>FreeBSD console 預設顯示模式可以調整為 1024x768、1280x1024
	或其他顯示卡與顯示器支援的解析度大小。要切換顯示模式，
	必須先重新編譯加入下面這兩個選項的 kernel：</para>

      <programlisting>options VESA
options SC_PIXEL_MODE</programlisting>

      <para>一旦 kernel 有加入這兩項並重新編譯完畢，就能用 &man.vidcontrol.1;
	工具來偵測您的硬體支援哪些顯示模式，要列出支援的顯示模式就打：</para>

      <screen>&prompt.root; <userinput>vidcontrol -i mode</userinput></screen>

      <para>該指令會顯示此硬體支援的顯示模式清單。然後可以在
	<username>root</username> console 內透過 &man.vidcontrol.1; 指令，
	選擇模式：</para>

      <screen>&prompt.root; <userinput>vidcontrol MODE_279</userinput></screen>

      <para>若對新的顯示模式覺得還不錯，想要每次開機時自動生效，可以在
	<filename>/etc/rc.conf</filename> 裡這樣設定：</para>

      <programlisting>allscreens_flags="MODE_279"</programlisting>
  </sect1>

  <sect1 id="permissions">
    <title>權限</title>
    <indexterm><primary>UNIX</primary></indexterm>

    <para>FreeBSD 源自於 BSD &unix;，繼承了幾個重要的 &unix; 概念。
      首先也最明顯，它是一款 multi-user 作業系統。 它可以同時處理多人多工，
      負責徹底的分享與管理來自每位使用者對硬碟裝置、週邊設備、記憶體及
      CPU 時間的要求。</para>

    <para>也因為系統能夠支援多使用者，
      所以系統管理的一切都有權限來決定誰可以讀取、寫入或執行資源。
      這些權限分別使用三組八進位的數字儲存，一組代表檔案的所有者，
      一組代表檔案所屬的群組，而最後一組則代表其他所有人。
      表示這些數字的方式如下:</para>

    <indexterm><primary>permissions</primary></indexterm>
    <indexterm>
      <primary>file permissions</primary>
    </indexterm>
    <informaltable frame="none" pgwide="1">
      <tgroup cols="3">
	<thead>
	  <row>
	    <entry>值</entry>
	    <entry>權限</entry>
	    <entry>目錄顯示</entry>
	  </row>
	</thead>

	<tbody>
	  <row>
	    <entry>0</entry>
	    <entry>不可讀取, 不可寫入, 不可執行</entry>
	    <entry><literal>---</literal></entry>
	  </row>

	  <row>
	    <entry>1</entry>
	    <entry>不可讀取, 不可寫入, 可執行</entry>
	    <entry><literal>--x</literal></entry>
	  </row>

	  <row>
	    <entry>2</entry>
	    <entry>不可讀取, 可寫入, 不可執行</entry>
	    <entry><literal>-w-</literal></entry>
	  </row>

	  <row>
	    <entry>3</entry>
	    <entry>不可讀取, 可寫入, 可執行</entry>
	    <entry><literal>-wx</literal></entry>
	  </row>

	  <row>
	    <entry>4</entry>
	    <entry>可讀取, 不可寫入, 不可執行</entry>
	    <entry><literal>r--</literal></entry>
	  </row>

	  <row>
	    <entry>5</entry>
	    <entry>可讀取, 不可寫入, 可執行</entry>
	    <entry><literal>r-x</literal></entry>
	  </row>

	  <row>
	    <entry>6</entry>
	    <entry>可讀取, 可寫入, 不可執行</entry>
	    <entry><literal>rw-</literal></entry>
	  </row>

	  <row>
	    <entry>7</entry>
	    <entry>可讀取, 可寫入, 可執行</entry>
	    <entry><literal>rwx</literal></entry>
	  </row>
	</tbody>
      </tgroup>
    </informaltable>
    <indexterm>
      <primary><command>ls</command></primary>
    </indexterm>
    <indexterm><primary>directories</primary></indexterm>

    <para>使用 &man.ls.1; 指令時，可以加上 <option>-l</option> 參數，
      來檢視詳細的目錄清單。
      清單中欄位的資訊包含檔案對所有者、群組及其他人的權限。
      在任一個目錄底下執行 <command>ls -l</command>，會顯示如下的結果:
      </para>

    <screen>&prompt.user; <userinput>ls -l</userinput>
total 530
-rw-r--r--  1 root  wheel     512 Sep  5 12:31 myfile
-rw-r--r--  1 root  wheel     512 Sep  5 12:31 otherfile
-rw-r--r--  1 root  wheel    7680 Sep  5 12:31 email.txt
...</screen>

    <para>在這裡告所您該如何區分 <command>ls -l</command> 
      第一欄當中的資訊:</para>

    <screen>-rw-r--r--</screen>

    <para>第一個 (最左邊) 的字元用來表示這個檔案的類型為何，
      除標準檔案以外，尚有目錄、特殊字元裝置 (Special character device)、
      Socket 及其他特殊虛擬檔案裝置 (Special pseudo-file device)，
      在此例當中，<literal>-</literal> 表示該檔案為一個標準的檔案。
      範例中接下來的三個字元中，<literal>rw-</literal>
      代表所有者對檔案擁有的權限。 再接下來的三個字元，
      <literal>r--</literal> 則代表群組對檔案擁有的權限，
      最後三個字元，<literal>r--</literal> 則代表其他人對檔案擁有的權限。
      破折號 (-) 表示沒有權限，範例中的這個檔案的權限，
      只允許所有者讀取、寫入檔案，群組以及其他人僅能讀取檔案。
      根據以上的表格，此種權限的檔案可以使用 <literal>644</literal> 來表示，
      每組數字分別代表檔案的三種權限。</para>

    <para>以上是不錯的方式，但系統該如何控制裝置的權限？ 實際上 FreeBSD
      對大多的硬碟裝置就如同檔案，程式可以開啟、讀取以及寫入資料如一般檔案。
      這些特殊裝置檔案 (Special device file) 都儲存於 <filename>/dev</filename> 
      目錄中。</para>

    <para>
      目錄也同如檔案，擁有讀取、寫入及執行的權限，
      但在執行權限上與檔案有明顯的差異。 當目錄被標示為可執行時，代表可以使用
      <quote>cd</quote> (更改目錄) 進入該目錄。
      也代表能夠存取在此目錄之中的已知檔名的檔案
      (當然，檔案仍擁有自己的權限)</para>

    <para>尤其，要能夠列出目錄內容，必須擁有目錄的讀取權限。
      而當要刪除已知檔名的檔案時，也必須擁有檔案所在目錄的寫入
      <emphasis>以及</emphasis> 執行的權限。</para>

    <para>還有一些權限，但這些權限主要在特殊情況使用，如
      setuid binaries 及 sticky directories。
      如果您還想知道更多檔案權限的資訊及使用方法，請務必參閱
      &man.chmod.1; 說明文件。</para>

    <sect2>
      <sect2info>
	<authorgroup>
	  <author>
	    <firstname>Tom</firstname>
	    <surname>Rhodes</surname>
	    <contrib>Contributed by </contrib>
	  </author>
	</authorgroup>
      </sect2info>

      <title>權限符號</title>
      <indexterm><primary>permissions</primary><secondary>symbolic</secondary></indexterm>

      <para>權限符號可稱做符號表示，
	使用字元的方式來取代使用數值來設定檔案或目錄的權限。
	符號表示的格式依序為 (某人)(動作)(權限)，可使用的符號如下:</para>

      <informaltable frame="none" pgwide="1">
	<tgroup cols="3">
	  <thead>
	    <row>
	      <entry>項目</entry>
	      <entry>字母</entry>
	      <entry>意義</entry>
	    </row>
	  </thead>

	<tbody>
	  <row>
	    <entry>(某人)</entry>
	    <entry>u</entry>
	    <entry>使用者</entry>
	  </row>

	  <row>
	    <entry>(某人)</entry>
	    <entry>g</entry>
	    <entry>群組所有者</entry>
	  </row>

	  <row>
	    <entry>(某人)</entry>
	    <entry>o</entry>
	    <entry>其他</entry>
	  </row>

	  <row>
	    <entry>(某人)</entry>
	    <entry>a</entry>
	    <entry>全部(<quote>world</quote>)</entry>
	  </row>

	  <row>
	    <entry>(動作)</entry>
	    <entry>+</entry>
	    <entry>增加權限</entry>
	  </row>

	  <row>
	    <entry>(動作)</entry>
	    <entry>-</entry>
	    <entry>移除權限</entry>
	  </row>

	  <row>
	    <entry>(動作)</entry>
	    <entry>=</entry>
	    <entry>指定權限</entry>
	  </row>

	  <row>
	    <entry>(權限)</entry>
	    <entry>r</entry>
	    <entry>讀取</entry>
	  </row>

	  <row>
	    <entry>(權限)</entry>
	    <entry>w</entry>
	    <entry>寫入</entry>
	  </row>

	  <row>
	    <entry>(權限)</entry>
	    <entry>x</entry>
	    <entry>執行</entry>
	  </row>

	  <row>
	    <entry>(權限)</entry>
	    <entry>t</entry>
	    <entry>Sticky bit</entry>
	  </row>

	  <row>
	    <entry>(權限)</entry>
	    <entry>s</entry>
	    <entry>Set UID 或 GID</entry>
	  </row>
	</tbody>
      </tgroup>
    </informaltable>

    <para>如先前同樣使用 &man.chmod.1; 指令來設定，但改用這些字元當作參數。
      例如，您可以使用下列指令禁止其他使用者存取檔案
      <replaceable>FILE</replaceable>:</para>

    <screen>&prompt.user; <userinput>chmod go= FILE</userinput></screen>

    <para>若有兩個以上的符號表示可以使用逗號 (,) 區隔。
      例如，下列指令將會移除群組及其他人對檔案 
      <replaceable>FILE</replaceable> 的寫入權限，
      並使全部人(<quote>world</quote>)對該檔有執行權限。</para>

    <screen>&prompt.user; <userinput>chmod go-w,a+x <replaceable>FILE</replaceable></userinput></screen>

<!--
    <para>Most users will not notice this, but it should be pointed out
      that using the octal method will only set or assign permissions to
      a file; it does not add or delete them.</para>
-->
    </sect2>

    <sect2>
      <sect2info>
	<authorgroup>
	  <author>
	    <firstname>Tom</firstname>
	    <surname>Rhodes</surname>
	    <contrib>Contributed by </contrib>
	  </author>
	</authorgroup>
      </sect2info>

      <title>&os; 檔案旗標 (Flag)</title>

      <para>除了前面提到的檔案權限外，&os; 支援使用 <quote>檔案旗標</quote>。
	這些旗標增加了檔案的安全性及管理性，但不包含目錄。</para>

      <para>檔案旗標增加了管理性，確保在某些時候 <username>root</username>
	不會意外將檔案修改或移除。</para>

      <para>修改的檔案 flag 僅需要使用擁有簡易的介面的 &man.chflags.1; 工具。
	例如，標示系統禁止刪除的旗標於檔案
	<filename>file1</filename>，使用下列指令：</para>

      <screen>&prompt.root; <userinput>chflags sunlink <filename>file1</filename></userinput></screen>

      <para>若要移除系統禁止刪除的旗標，只需要簡單在 <option>sunlink</option>
	前加上 <quote>no</quote>，例如：</para>

      <screen>&prompt.root; <userinput>chflags nosunlink <filename>file1</filename></userinput></screen>

      <para>使用 &man.ls.1; 及參數 <option>-lo</option>
	可檢視檔案目前的旗標：</para>

      <screen>&prompt.root; <userinput>ls -lo <filename>file1</filename></userinput></screen>

      <para>輸出的結果如下:</para>

      <programlisting>-rw-r--r--  1 trhodes  trhodes  sunlnk 0 Mar  1 05:54 file1</programlisting>

      <para>多數的旗標僅能由 <username>root</username>
	使用者來標示或移除，而部份旗標可由檔案所有者設定。
	我們建議系統管理者可閱讀 &man.chflags.1; 及 &man.chflags.2; 
	說明以瞭解相關細節。</para>
    </sect2>

    <sect2>
      <sect2info>
	<authorgroup>
	  <author>
	    <firstname>Tom</firstname>
	    <surname>Rhodes</surname>
	    <contrib>Contributed by </contrib>
	  </author>
	</authorgroup>
      </sect2info>

      <title>setuid、setgid、sticky 權限</title>

      <para>除了之前討論過的權限外，有三個系統管理者都應該知道的特殊設定，就是
	<literal>setuid</literal>、 <literal>setgid</literal>、<literal>sticky</literal>
	權限。</para>

      <para>這些設定提供平常不授權一般使用者的功能，在一些 &unix; 操作上舉足輕重。
	要搞懂它們, 也得知道真實使用者 ID (real user ID) 和有效使用者 ID (effective user ID) 的差異。</para>

      <para>真實使用者 ID 是程序所有者或啟動者的 <acronym>UID</acronym>。
	有效 <acronym>UID</acronym> 是程序運行時實際身分的使用者 ID。
	舉例來說，使用者更改密碼時，以他的真實使用者 ID 運行 &man.passwd.1;
	工具；然而為了操作密碼資料庫，它是以
	<username>root</username> 使用者身分的有效 ID 運行。
	因此一般使用者更改密碼時不會遇到
	<errorname>Permission Denied</errorname> 錯誤。</para>

      <note>
	<para>&man.mount.8; 的 <literal>nosuid</literal> 選項會使
	  這些 binaries 失效且不警告使用者。這選項也非萬無一失，根據
	  &man.mount.8; manual page，<literal>nosuid</literal> 
	  軟體層 (wrapper) 或許可以規避限制。</para>
      </note>

      <para>setuid 權限可在一般權限數值前面加上數字 4 來設定，如下面的例子：</para>

      <screen>&prompt.root; <userinput>chmod 4755 suidexample.sh</userinput></screen>

      <para><filename><replaceable>suidexample.sh</replaceable></filename>
	檔案權限現在應該如下所示:</para>

      <programlisting>-rwsr-xr-x   1 trhodes  trhodes    63 Aug 29 06:36 suidexample.sh</programlisting>

      <para>這個例子該注意的是檔案所有者的權限值，執行位元現在換成了
	<literal>s</literal> 。藉此，像 <command>passwd</command>
	這類需要提升權限的工具才能順利運作。</para>

      <para>開兩個終端機以便即時觀察。
	在其一以一般使用者身分啟動
	<command>passwd</command> 程序。當它等著輸入新密碼時，
	檢查程序表及看看 <command>passwd</command>
	指令的使用者資訊。</para>

      <para>終端機甲：</para>

      <screen>Changing local password for trhodes
Old Password:</screen>

      <para>終端機乙：</para>

      <screen>&prompt.root; <userinput>ps aux | grep passwd</userinput></screen>

      <screen>trhodes  5232  0.0  0.2  3420  1608   0  R+    2:10AM   0:00.00 grep passwd
root     5211  0.0  0.2  3620  1724   2  I+    2:09AM   0:00.01 passwd</screen>

      <para>如上所示，由一般使用者運行
	<command>passwd</command>，但它使用的是
	<username>root</username> 的有效 <acronym>UID</acronym>。</para>

      <para><literal>setgid</literal> 權限展現的功能如同
	<literal>setuid</literal> 權限，不過更動的是群組設定。
	當應用程式或工具依此設定運行，將被授予此檔案所屬群組的權限，
	而非啟動此程序的使用者權限。</para>

      <para>要設定檔案的 <literal>setgid</literal> 權限，
	<command>chmod</command> 指令參數以 2 開頭，如下面的例子：</para>

      <screen>&prompt.root; <userinput>chmod 2755 sgidexample.sh</userinput></screen>

      <para>新設定看起來差不多, 注意現在顯示群組權限設定的欄位有了
	<literal>s</literal>：<para>

      <screen>-rwxr-sr-x   1 trhodes  trhodes    44 Aug 31 01:49 sgidexample.sh</screen>

      <note>
	<para>即使 shell script 是否為執行檔仍未有定論，在這些例子中並不會以不同的
	  <acronym>EUID</acronym>　——有效使用者 ID ——運行。
	  因為 shell script 不能使用
	  &man.setuid.2; 系統呼叫。</para>
      </note>

      <para>由於我們討論過的前兩個特殊權限位元 （<literal>setuid</literal>
	和 <literal>setgid</literal>　權限位元）能提升權限，
	或許會削弱系統安全。有第三個特殊權限位元能加強系統安全：
	<literal>sticky bit</literal>。</para>

      <para>當 <literal>sticky bit</literal> 設定在目錄時，
	檔案只能由檔案擁有者刪除。這種權限設定十分有用，可避免像在
	<filename class="directory">/tmp</filename> 這樣的公用目錄中，
	使用者刪除非他所有的檔案。要利用此權限，權限值前加個 1，例如：</para>

      <screen>&prompt.root; <userinput>chmod 1777 /tmp</userinput></screen>

      <para>現在可用 <command>ls</command> 指令看到效果：</para>

      <screen>&prompt.root; <userinput>ls -al / | grep tmp</userinput></screen>

      <screen>drwxrwxrwt  10 root  wheel         512 Aug 31 01:49 tmp</screen>

      <para><literal>sticky bit</literal> 可從設定值結尾的
	<literal>t</literal> 辨別。</para>
    </sect2>
  </sect1>
  
  <sect1 id="dirstructure">
    <title>目錄結構</title>
    <indexterm><primary>directory hierarchy</primary></indexterm>

    <para>認識 FreeBSD 的目錄架構，就可對系統有概略的基礎理解。
      最重要的莫過於整個目錄的根目錄，就是 <quote>/</quote> 目錄，
      該目錄會在開機時最先掛載 (mount)，裡面會有開機所會用到必備檔案。
      此外，根目錄還有紀錄其他檔案系統的掛載點相關設定。</para>

    <para>「掛載點」就是讓新增的檔案系統，能接到上層的檔案系統
      (通常就是「根目錄」檔案系統) 的目錄。
      在 <xref linkend="disk-organization"> 這邊對此有更詳細介紹。
      標準的掛載點包括了 <filename>/usr</filename>、<filename>/var</filename>、
      <filename>/tmp</filename>、<filename>/mnt</filename> 以及
      <filename>/cdrom</filename>。 這些目錄通常會記錄在
      <filename>/etc/fstab</filename> 設定檔內。
      <filename>/etc/fstab</filename> 是記錄各檔案系統及相關掛載點的表格。
      大部分在 <filename>/etc/fstab</filename> 有記錄的檔案系統，會在開機時由
      &man.rc.8; script 來自動掛載，除非它們有設定 <option>noauto</option>
      選項。 其中細節說明可參閱 <xref linkend="disks-fstab">。</para>

    <para>有關檔案系統架構的完整說明可參閱 &man.hier.7;。
      現在呢，讓我們大致先一窺常見的目錄有哪些吧。</para>

    <para>
      <informaltable frame="none" pgwide="1">
        <tgroup cols="2">
	  <thead>
	    <row>
	      <entry>目錄</entry>
	      <entry>說明</entry>
	    </row>
	  </thead>
	  <tbody valign="top">
            <row>
	      <entry><filename class="directory">/</filename></entry>
	      <entry>檔案系統的根目錄。</entry>
            </row>

	    <row>
	      <entry><filename class="directory">/bin/</filename></entry>
	      <entry>single-user、multi-user 兩種模式皆可使用的基本工具
		。</entry>
	    </row>

	    <row>
	      <entry><filename class="directory">/boot/</filename></entry>
	      <entry>作業系統開機過程會用到的程式、設定檔。</entry>
	    </row>

	    <row>
	      <entry><filename class="directory">/boot/defaults/</filename></entry>
	      <entry>預設的開機啟動設定檔，詳情請參閱 &man.loader.conf.5;
		。</entry>
	    </row>

	    <row>
	      <entry><filename class="directory">/dev/</filename></entry>
	      <entry>Device nodes，詳情請參閱 &man.intro.4;。</entry>
	    </row>

	    <row>
	      <entry><filename class="directory">/etc/</filename></entry>
	      <entry>系統設定檔及一些 script 檔。</entry>
	    </row>

	    <row>
	      <entry><filename class="directory">/etc/defaults/</filename></entry>
	      <entry>預設的系統設定檔，詳情請參閱 &man.rc.8;。</entry>
	    </row>

	    <row>
	      <entry><filename class="directory">/etc/mail/</filename></entry>
	      <entry>MTA(Mail Transport Agent)的相關設定檔，像是
		&man.sendmail.8;。</entry>
	    </row>

	    <row>
	      <entry><filename class="directory">/etc/namedb/</filename></entry>
	      <entry><command>named</command> 設定檔，詳情請參閱
		&man.named.8;。</entry>
	    </row>

	    <row>
	      <entry><filename class="directory">/etc/periodic/</filename></entry>
	      <entry>每日、每週、每月透過 &man.cron.8;; 執行的定期排程 script，
		詳情請參閱 &man.periodic.8;。</entry>
	    </row>

	    <row>
	      <entry><filename class="directory">/etc/ppp/</filename></entry>
	      <entry><command>ppp</command> 設定檔，詳情請參閱 
		&man.ppp.8;。</entry>
	    </row>

	    <row>
	      <entry><filename class="directory">/mnt/</filename></entry>
	      <entry>系統管理者慣用充當臨時掛載點的空目錄。</entry>
	    </row>

	    <row>
	      <entry><filename class="directory">/proc/</filename></entry>
	      <entry>Process 檔案系統，詳情請參閱 &man.procfs.5; 及
		&man.mount.procfs.8;。</entry>
	    </row>

	    <row>
	      <entry><filename class="directory">/rescue/</filename></entry>
	      <entry>緊急救援用途的一些 statically linked 程式，詳情請參閱 
		&man.rescue.8;。</entry>
	    </row>

	    <row>
	      <entry><filename class="directory">/root/</filename></entry>
	      <entry><username>root</username> 帳號的家目錄。</entry>
	    </row>

	    <row>
	      <entry><filename class="directory">/sbin/</filename></entry>
	      <entry>供 single-user 及 multi-user 環境使用的系統程式及管理工具
		。</entry>
	    </row>

	    <row>
	      <entry><filename class="directory">/tmp/</filename></entry>
	      <entry>臨時檔案。一般而言，重開機之後
		<filename class="directory">/tmp</filename> 內的東西會被清除掉。
		而通常會將 memory-based 檔案系統掛載在 
		<filename class="directory">/tmp</filename> 上。
		這些瑣事可透過 tmpmfs 相關的 &man.rc.conf.5; 環境變數來自動完成
		。(或是在 <filename>/etc/fstab</filename> 內做設定，
		詳情請參閱 &man.mdmfs.8;。)</entry>
	    </row>

	    <row>
	      <entry><filename class="directory">/usr/</filename></entry>
	      <entry>主要是使用者所安裝的工具程式、應用程式存放處。</entry>
	    </row>

	    <row>
	      <entry><filename class="directory">/usr/bin/</filename></entry>
	      <entry>常用工具、開發工具、應用軟體。</entry>
	    </row>

	    <row>
	      <entry><filename class="directory">/usr/include/</filename></entry>
	      <entry>標準 C include 的相關 header 檔案庫。</entry>
	    </row>

	    <row>
	      <entry><filename class="directory">/usr/lib/</filename></entry>
	      <entry>函式庫存放處。</entry>
	    </row>

	    <row>
	      <entry><filename class="directory">/usr/libdata/</filename></entry>
	      <entry>其他各式工具的資料檔。</entry>
	    </row>

	    <row>
	      <entry><filename class="directory">/usr/libexec/</filename></entry>
	      <entry>系統 daemons 及系統工具程式(透過其他程式來執行)。</entry>
	    </row>

	    <row>
	      <entry><filename
	      class="directory">/usr/local/</filename></entry>

	      <entry>存放一些自行安裝的執行檔、函式庫等等。 同時，也是 FreeBSD
		ports 架構的預設安裝目錄。 <filename>/usr/local</filename>
		內的目錄架構大致與 <filename>/usr</filename> 相同，詳情請參閱
		&man.hier.7; 說明。 但 man 目錄例外，它們是直接放在
		<filename>/usr/local</filename> 底下，而非
		<filename>/usr/local/share</filename>，而 ports 
		所安裝的說明文件則在
		<filename>share/doc/<replaceable>port</replaceable></filename>。
	      </entry>
	    </row>

	    <row>
	      <entry><filename class="directory">/usr/obj/</filename></entry>
	      <entry>在編譯 <filename>/usr/src</filename> 
		目錄時所產生的相關架構 object 檔案。</entry>
	    </row>
	    
	    <row>
	      <entry><filename class="directory">/usr/ports/</filename></entry>
	      <entry>FreeBSD Ports Collection (optional)。</entry>
	    </row>
	    
	    <row>
	      <entry><filename class="directory">/usr/sbin/</filename></entry>
	      <entry>系統 daemon 及系統工具(直接由使用者執行)。</entry>
	    </row>
	    
	    <row>
	      <entry><filename class="directory">/usr/share/</filename></entry>
	      <entry>各架構皆共通的檔案。</entry>
	    </row>
	    
	    <row>
	      <entry><filename class="directory">/usr/src/</filename></entry>
	      <entry>BSD 本身的原始碼(或自行新增的)。</entry>
	    </row>
	    
	    <row>
	      <entry><filename
	      class="directory">/usr/X11R6/</filename></entry>
	      <entry>X11R6 相關套件的執行檔、函式庫等(optional)。</entry>
	    </row>
	    
	    <row>
	      <entry><filename class="directory">/var/</filename></entry>
	      <entry>存放各種用途的 log 檔、臨時或暫時存放、列印或郵件的 
		spool 檔案。有時候，memory-based 檔案系統也會掛載在
		<filename class="directory">/var</filename>。
		這些瑣事可透過 varmfs 相關的 &man.rc.conf.5 
		環境變數來自動完成。(或是在 
		<filename>/etc/fstab</filename> 內做設定，相關細節請參閱 
		&man.mdmfs.8;。)</entry>
	    </row>
	    
	    
	    <row>
	      <entry><filename class="directory">/var/log/</filename></entry>
	      <entry>各項系統記錄的 log 檔案。</entry>
	    </row>
	    
	    <row>
	      <entry><filename class="directory">/var/mail/</filename></entry>
	      <entry>各使用者的 mailbox 檔案。</entry>
	    </row>
	    
	    <row>
	      <entry><filename class="directory">/var/spool/</filename></entry>
	      <entry>各種印表機、郵件系統的 spool 目錄。</entry>
	    </row>
	    
	    <row>
	      <entry><filename class="directory">/var/tmp/</filename></entry>
	      <entry>臨時檔案。
		這些檔案在重開機後通常仍會保留，除非
		<filename class="directory">/var</filename>
		是屬於 memory-based 檔案系統。</entry>
	    </row>
	    
	    <row>
	      <entry><filename class="directory">/var/yp/</filename></entry>
	      <entry>記錄 NIS maps。</entry>
	    </row>

	  </tbody>
	</tgroup>
      </informaltable>
    </para>

  </sect1>

  <sect1 id="disk-organization">
      <title>磁碟組織</title>

      <para>FreeBSD 用來尋找檔案的最小單位就是檔案的名稱了。
	檔案的名稱有大小寫之分，所以說 <filename>readme.txt</filename>
	和 <filename>README.TXT</filename> 是兩個不同的檔案。
	FreeBSD 並不使用副檔名 (<filename>.txt</filename>)
        來判別這是一個程式檔、文件檔或是其他類型的檔案。</para>

      <para>檔案存在目錄裡面。
	一個目錄中可能沒有任何檔案，也可能有好幾百個檔案。
	目錄之中也可以包含其他的目錄；
	您可以建立階層式的目錄以便資料的管理。</para>

      <para>檔案或目錄的對應是藉由給定的檔案或目錄名稱，然後加上正斜線符號
	(<literal>/</literal>)；之後再視需要加上其他的目錄名稱。
	如果您有一個目錄 <filename>foo</filename> ，裡面有一個目錄叫作
	<filename>bar</filename>，這個目錄中又包含了一個叫
	<filename>readme.txt</filename>
	的檔案，那麼這個檔案的全名，或者說檔案的<firstterm>路徑</firstterm>就是
	<filename>foo/bar/readme.txt</filename>。</para>

      <para>目錄及檔案儲存在檔案系統之中。
	每個檔案系統都有唯一一個最上層的目錄，叫做<firstterm>根目錄
	(root directory)</firstterm>。
	然後在這個根目錄下面才能有其他的目錄。</para>

      <para>到目前為止大概和其他您用過的作業系統都差不多。
	還是有些不一樣的地方就是了，例如 &ms-dos; 用 <literal>\</literal>
	當檔案和目錄名稱的分隔符號，而 &macos; 則是用 <literal>:</literal>
        符號。</para>

      <para>FreeBSD 的路徑中並沒有使用磁碟機代號或其他的磁碟名稱。
	因此，您不可以使用像 <filename>c:/foo/bar/readme.txt</filename>
	這樣子的檔案名稱。</para>

      <para>相對的，在 FreeBSD 
	系統中有一個檔案系統被指定為<firstterm>根檔案系統</firstterm>。
	根檔案系統的根目錄由 <literal>/</literal> 表示。
	然後其他的檔案系統再<firstterm>掛載 (mount)</firstterm>
	在根檔案系統之下。因此無論您的 FreeBSD
	系統上有多少顆硬碟，每一個目錄看起來就像在同一個磁碟上。</para>

      <para>假設您有三個檔案系統，分別叫作 <literal>A</literal>、
	<literal>B</literal> 及 <literal>C</literal>。
	每個檔案系統都包含兩個目錄，叫做
	<literal>A1</literal>、<literal>A2</literal> (依此類推得
	<literal>B1</literal>、<literal>B2</literal> 及
	<literal>C1</literal>、<literal>C2</literal>)。</para>

      <para>稱 <literal>A</literal> 為主要的檔案系統；如果您用
	<command>ls</command> 指令查看此目錄的內容，您會看到兩個子目錄：
	<literal>A1</literal> 及 <literal>A2</literal>，如下所示：</para>

      <mediaobject>
	<imageobject>
	  <imagedata fileref="install/example-dir1" format="EPS">
	</imageobject>

	<textobject>
	  <literallayout class="monospaced"> /
 |
 +--- A1
 |
 `--- A2</literallayout>
	</textobject>
      </mediaobject>

      <para>一個檔案系統必須以目錄形式掛載於另一個檔案系統上。
	因此，假設您將 <literal>B</literal> 掛載於 <literal>A1</literal>
	之上，則 <literal>B</literal> 的根目錄就變成了
	<literal>A1</literal>，而在 <literal>B</literal>
	之下的任何目錄的路徑也隨之改變:</para>

      <mediaobject>
	<imageobject>
	  <imagedata fileref="install/example-dir2" format="EPS">
	</imageobject>

	<textobject>
	  <literallayout class="monospaced"> /
 | 
 +--- A1
 |     |
 |     +--- B1
 |     |
 |     `--- B2
 |
 `--- A2</literallayout>
	</textobject>
      </mediaobject>

      <para>在 <literal>B1</literal> 或	<literal>B2</literal>
	目錄中的任何檔案必須經由路徑 <filename>/A1/B1</filename>
	或 <filename>/A1/B2</filename> 才能達到。
	所有原來在 <filename>/A1</filename> 中的檔案會暫時被隱藏起來，直到
	<literal>B</literal> 被「<firstterm>移除
	(unmounted)</firstterm>」後才會再顯現出來。</para>

      <para>如果 <literal>B</literal> 掛載在 <literal>A2</literal>
	之上，則會變成：</para>

      <mediaobject>
	<imageobject>
	  <imagedata fileref="install/example-dir3" format="EPS">
	</imageobject>

	<textobject>
	  <literallayout class="monospaced"> /
 |
 +--- A1
 |
 `--- A2
       |
       +--- B1
       |
       `--- B2</literallayout>
	</textobject>
      </mediaobject>

      <para>上面的路徑分別為 <filename>/A2/B1</filename> 及
	<filename>/A2/B2</filename>。</para>

      <para>檔案系統可以掛在其他檔案系統的目錄之上。
	延續之前的例子，<literal>C</literal> 檔案系統可以掛在檔案系統
	<literal>B</literal> 的 <literal>B1</literal>
	目錄之上，如圖所示：</para>

      <mediaobject>
	<imageobject>
	  <imagedata fileref="install/example-dir4" format="EPS">
	</imageobject>
	
	<textobject>
	  <literallayout class="monospaced"> /
 |
 +--- A1
 |
 `--- A2
       |
       +--- B1
       |     |
       |     +--- C1
       |     |
       |     `--- C2
       |
       `--- B2</literallayout>
	</textobject>
      </mediaobject>

      <para>或者 <literal>C</literal> 直接掛載於 <literal>A</literal> 的
	<literal>A1</literal> 目錄之上：</para>

      <mediaobject>
	<imageobject>
	  <imagedata fileref="install/example-dir5" format="EPS">
	</imageobject>

	<textobject>
	  <literallayout class="monospaced"> /
 |
 +--- A1
 |     |
 |     +--- C1
 |     |
 |     `--- C2
 |
 `--- A2
       |
       +--- B1
       |
       `--- B2</literallayout>
	</textobject>
      </mediaobject>

      <para>如果您熟悉 &ms-dos; 的話，這和 <command>join</command>
	指令很類似——雖然不盡相同。</para>

      <para>一般情況下您不需要擔心這些東西。
	除非您要安裝新的磁碟，不然通常在您安裝 FreeBSD
        時建立好檔案系統並決定好要掛載在何處之後就不會再做任何更動了。</para>

      <para>您完全可以使用單一個大型根檔案系統 (root file system)
	而不建立其他的檔案系統。這作法有好有壞。</para>

      <itemizedlist>
	<title>使用多個檔案系統的好處</title>
      
	<listitem>
	  <para>不同的檔案系統在掛上的時候可以有不同的
	    <firstterm>掛載參數</firstterm>。
	    舉例來說，為求謹慎您可以將根檔案系統設成唯讀，
	    以避免不小心刪除或修改掉重要的檔案。
	    將使用者可寫入的檔案系統 (例如 <filename>/home</filename>)
	    獨立出來也可以讓他們用 <firstterm>nosuid</firstterm>
	    的參數掛載，此選項可以讓在這個檔案系統中執行檔的
	    <firstterm>suid</firstterm>/<firstterm>guid</firstterm>
	    bits 失效，也許可以讓系統更安全。</para>
	</listitem>

	<listitem>
	  <para>FreeBSD 會自動根據您檔案系統的使用方式來做最佳的檔案配置方式。
	    因此，一個有很多小檔案、
	    常常寫入的檔案系統跟只有幾個較大的檔案的檔案系統配置是不一樣的。
	    如果您只有單一個大型檔案系統，這部分就沒用了。</para>
	</listitem>
	
	<listitem>
	  <para>FreeBSD 的檔案系統在停電的時候很穩固。
	    然而，在某些重要的時候停電仍然會對檔案系統結構造成損害。
	    分割成許多個檔案系統的話在系統在停電後比較能夠正常啟動，
	    以便您在需要的時候將備份資料回存回來。</para>
	</listitem>
      </itemizedlist>

      <itemizedlist>
	<title>使用單一檔案系統的好處</title>

	<listitem>
	  <para>檔案系統的大小是固定的。
	    您當初安裝 FreeBSD
	    的時候應該會給定一個大小，可是後來您可能會想把空間加大。
	    如果沒有備份的話是很難達成的；
	    您必須將檔案系統重新建立為您需要的大小，然後將備份回存回來。</para>

	  <important>
	    <para>FreeBSD 的 &man.growfs.8;
	      指令可以突破此限制直接變更檔案系統的大小。</para>
	  </important>
	</listitem>
      </itemizedlist>
    
      <para>檔案系統包含在分割區裡面。
	因為 &os; 承襲 &unix 架構，這邊講的分割區和一般提到的分割區
	(例如 &ms-dos; 分割區) 不同。每一個分割區由一個代號(字母)表示，從
	<literal>a</literal> 到 <literal>h</literal>。
	每個分割區只能包含一個檔案系統。
	因此除了說常見到用檔案系統同的掛載點來表示檔案系統外，
	也可以用包含他的分割區代號來表示。</para>

      <para>FreeBSD 也會拿磁碟空間來當 <firstterm>swap space</firstterm>。
        Swap space 給 FreeBSD 當作<firstterm>虛擬記憶體</firstterm>用。
	這讓您的電腦好像擁有比實際更多的記憶體。
	當 FreeBSD 的記憶體用完的時候，它會把一些目前沒用到的資料移到
	swap space，然後在用到的時候移回去 (同時移出部份沒用到的)。</para>

      <para>某些分割區有慣例的使用方式如下：</para>

      <informaltable frame="none" pgwide="1">
	<tgroup cols="2">
	  <colspec colwidth="1*">
	  <colspec colwidth="5*">

	  <thead>
	    <row>
	      <entry>分割區</entry>

	      <entry>慣例</entry>
	    </row>
	  </thead>

	  <tbody valign="top">
	    <row>
	      <entry><literal>a</literal></entry>

	      <entry>通常包含根檔案系統 (root file system)</entry>
	    </row>

	    <row>
	      <entry><literal>b</literal></entry>

	      <entry>通常是 swap space</entry>
	    </row>

	    <row>
	      <entry><literal>c</literal></entry>

	      <entry>通常和整個 slice 的大小一樣，給一些會用到整個 slice
		的工具程式（例如硬碟壞軌檢查工具）來使用。
		一般來說您應該不會把檔案系統建立在這個分割區。</entry>
	    </row>

	    <row>
	      <entry><literal>d</literal></entry>

	      <entry>分割區 <literal>d</literal> 
		曾經有代表特殊意義，但是已經不再使用。
		所以現在 <literal>d</literal>
		就和其他一般的分割區相同了。</entry>
	    </row>
	  </tbody>
	</tgroup>
      </informaltable>

      <para>每個包含有檔案系統的分割區是存在所謂的
	<firstterm>slice</firstterm> 裡面。
	FreeBSD 的 slice 就是指平常我們稱為分割區 (partition) 的東西。
	同樣地，會這樣子稱呼也是因為 FreeBSD 的 &unix; 色彩。
	而 slice 是有編號的，從 1 號編到 4 號。</para>

	<indexterm><primary>slices</primary></indexterm>
	<indexterm><primary>partitions</primary></indexterm>
	<indexterm><primary>dangerously dedicated</primary></indexterm>

      <para>slice 號碼跟在裝置名稱後面，先接一個字母
	<literal>s</literal>，然後從 1 號開始編下去。
	因此 <quote>da0<emphasis>s1</emphasis></quote> 就是指第一個 SCSI
	硬碟的第一個 slice。 一個磁碟上只能有四個實體的 slice，但是在實體的
	slice 中您可以塞進適當類型的邏輯 slice。 這些延伸的 slice 編號從 5
	開始，所以 <quote>ad0<emphasis>s5</emphasis></quote> 是第一個 IDE
	硬碟上的第一個延伸 slice。 檔案系統在裝置 (device) 裡就是在一個 slice
	之中。</para>

      <para>Slices、<quote>dangerously dedicated</quote>
        模式的實體磁碟機，以及其他包含<firstterm>分割區(partition)</firstterm>
	的磁碟都是以字母 <literal>a</literal> 到 <literal>h</literal>
	的編號來表示。  編號是接在裝置名稱的後面的，因此
	<quote>da0<emphasis>a</emphasis></quote> 是磁碟機 da 上的第一個
	<quote>dangerously dedicated</quote>模式之分割區。
	而 <quote>ad1s3<emphasis>e</emphasis></quote>
	則是第二顆 IDE 硬碟上第三個 slice 的第五個分割區。</para>
	
      <para>最後，我們就可以把系統上的每個磁碟都區分出來了。
	一個磁碟的名稱會有一個代碼來表示這個磁碟的類型，接著是一個數字，
	表示這是哪一個磁碟。 這邊跟 slice 每個磁碟編號從 0 開始不一樣。
	常見的代碼可以參考 <xref linkend="basics-dev-codes">。</para>

      <para>當要參照一個分割區的時候，FreeBSD 會要您一併輸入包含這個分割區的
	slice 及磁碟機名稱；當要參照一個 slice 的時候，也必須輸入包含這個
	slice 的磁碟名稱。  怎麼做呢？首先先列出磁碟名稱，然後
	<literal>s</literal> 加上 slice 編號，最後再輸入分割區字母代號。
	範例可以參考 <xref linkend="basics-disk-slice-part">.</para>

      <para><xref linkend="basics-concept-disk-model">
	示範了一個基本的磁碟分布模式，相信對您有些幫助。</para>

      <para>要安裝 FreeBSD，您必須先建置磁碟的 slice，接著於 slice 中建立要給
	FreeBSD 用的分割區。 最後在這些分割區中建立檔案系統 (或 swap space)
	並決定要將這些檔案系統掛載於哪裡。</para>

      <table frame="none" pgwide="1" id="basics-dev-codes">
	<title>磁碟機代號</title>

	<tgroup cols="2">
          <colspec colwidth="1*">
          <colspec colwidth="5*">

	  <thead>
	    <row>
	      <entry>代號</entry>
	    
	      <entry>意義</entry>
	    </row>
	  </thead>

	  <tbody>
	    <row>
	      <entry><devicename>ad</devicename></entry>

	      <entry>ATAPI(IDE) 磁碟機</entry>
	    </row>

	    <row>
	      <entry><devicename>da</devicename></entry>
	      
	      <entry>SCSI 直接存取磁碟機</entry>
	    </row>
	    
	    <row>
	      <entry><devicename>acd</devicename></entry>
	      
	      <entry>ATAPI(IDE) 光碟機</entry>
	    </row>
	    
	    <row>
	      <entry><devicename>cd</devicename></entry>
	      
	      <entry>SCSI 光碟機</entry>
	    </row>
	    
	    <row>
	      <entry><devicename>fd</devicename></entry>
	      
	      <entry>軟碟機</entry>
	    </row>
	  </tbody>
	</tgroup>
      </table>
      
      <example id="basics-disk-slice-part">
	<title>磁碟、slice 及分割區命名範例</title>
	
	<informaltable frame="none" pgwide="1">
	  <tgroup cols="2">
            <colspec colwidth="1*">
            <colspec colwidth="5*">

	    <thead>
	      <row>
		<entry>名稱</entry>
		
		<entry>意義</entry>
	      </row>
	    </thead>
	    
	    <tbody>
	      <row>
		<entry><literal>ad0s1a</literal></entry>
		
		<entry>第一個 IDE 硬碟 (<literal>ad0</literal>) 上第一個 slice
		  (<literal>s1</literal>)的第一個分割區(<literal>a</literal>)
		  。</entry>
	      </row>

	      <row>
		<entry><literal>da1s2e</literal></entry>
		<entry>第二個 SCSI 硬碟 (<literal>da1</literal>) 上第二個 slice
		  (<literal>s2</literal>) 的第五個分割區 (<literal>e</literal>)
		  。</entry>
	      </row>
	    </tbody>
	  </tgroup>
	</informaltable>
      </example>

      <example id="basics-concept-disk-model">
	<title>磁碟的概念模型</title>

	<para>此圖顯示 FreeBSD 中接到系統的第一個 IDE 磁碟機內部配置圖。
	  假設這個磁碟的容量是 4&nbsp;GB，並且包含了兩個 2&nbsp;GB 的
	  slice (&ms-dos; 的分割區)。 第一個 slice 是 DOS 的
	  <devicename>C:</devicename> 磁碟機，第二個則安裝了 FreeBSD。
	  本範例的 FreeBSD 有三個分割區以及一個 swap 分割區。</para>

	<para>這三個分割區每個都是一個檔案系統。
	  <literal>a</literal> 分割是根 (root) 檔案系統；分割
	  <literal>e</literal> 是 <filename>/var</filename>；而
	  <literal>f</literal> 分割是 <filename>/usr</filename>
	  目錄結構。</para>

        <mediaobject>
          <imageobject>
            <imagedata fileref="install/disk-layout" format="EPS">
          </imageobject>
 
          <textobject>
	    <literallayout class="monospaced">.-----------------.  --.
|                 |    |
|  DOS / Windows  |    |
:                 :     &gt;  First slice, ad0s1
:                 :    |
|                 |    |
:=================:  ==:                               --.
|                 |    |  Partition a, mounted as /      |
|                 |     &gt; referred to as ad0s2a          |
|                 |    |                                 |
:-----------------:  ==:                                 |
|                 |    |  Partition b, used as swap      |
|                 |     &gt; referred to as ad0s2b          |
|                 |    |                                 |
:-----------------:  ==:                                 |  Partition c, no
|                 |    |  Partition e, used as /var       &gt; file system, all 
|                 |     &gt; referred to as ad0s2e          |  of FreeBSD slice,
|                 |    |                                 |  ad0s2c
:-----------------:  ==:                                 |
|                 |    |                                 |
:                 :    |  Partition f, used as /usr      |
:                 :     > referred to as ad0s2f          |
:                 :    |                                 |
|                 |    |                                 |
|                 |  --'                                 |
`-----------------'                                    --'</literallayout>
          </textobject>
        </mediaobject>
      </example>
  </sect1>



  <sect1 id="mount-unmount">
    <title>掛載與卸載檔案系統</title>

    <para>檔案系統就像一顆樹。<filename>/</filename>
      就像是樹根，而 <filename>/dev</filename>，<filename>/usr</filename>
      以及其他在根目錄下的目錄就像是樹枝，而這些樹枝上面又還有分支，像是
      <filename>/usr/local</filename> 等。</para>

    <indexterm><primary>根檔案系統</primary></indexterm>
    <para>因為某些原因，我們會將一些目錄分別放在不同的檔案系統上。
      如 <filename>/var</filename> 包含了可能會滿出來的
      <filename>log/</filename>，<filename>spool/</filename>
      等目錄以及各式各樣的暫存檔。
      把根檔案系統塞到滿出來顯然不是個好主意，所以我們往往會比較傾向把
      <filename>/var</filename> 從 <filename>/</filename> 中拉出來。</para>

    <para>另一個常見到把某些目錄放在不同檔案系統上的理由是：
      這些檔案在不同的實體或虛擬磁碟機上。
      像是<link linkend="network-nfs">網路檔案系統</link>
      (Network File System) 或是光碟機。</para>

    <sect2 id="disks-fstab">
      <title> <filename>fstab</filename> 檔</title>
      <indexterm>
	<primary>檔案系統 file systems</primary>
	<secondary>由fstab掛載 mounted with fstab</secondary>
      </indexterm>

      <para>在 <filename>/etc/fstab</filename>
	裡面有設定的檔案系統會在<link linkend="boot">開機</link>
	的過程中自動地被掛載
	(除非該檔案系統有被加上 <option>noauto</option> 參數)。</para>

      <para><filename>/etc/fstab</filename> 檔案內容的格式如下：</para>

      <programlisting><replaceable>device</replaceable>       <replaceable>/mount-point</replaceable> <replaceable>fstype</replaceable>     <replaceable>options</replaceable>      <replaceable>dumpfreq</replaceable>     <replaceable>passno</replaceable></programlisting>

      <variablelist>
	<varlistentry>
	  <term><literal>device</literal></term>
	  <listitem>
	    <para>裝置名稱 (該裝置必須真的存在)。 詳情請參閱
	      <xref linkend="disks-naming">.</para>
	  </listitem>
	</varlistentry>

	<varlistentry>
	  <term><literal>mount-point</literal></term>
            
	  <listitem><para>檔案系統要掛載到的目錄 (該目錄必須真的存在)。</para>
	  </listitem>
	</varlistentry>
          
	<varlistentry>
	  <term><literal>fstype</literal></term>
            
	  <listitem>
	    <para>檔案系統類型，這是要傳給 &man.mount.8; 的參數。
	      FreeBSD 預設的檔案系統是 <literal>ufs</literal>。</para>
	  </listitem>
	</varlistentry>
          
	<varlistentry>
	  <term><literal>options</literal></term>
            
	  <listitem>
	    <para>可讀可寫的檔案系統用 
	      <option>rw</option>，而唯讀的檔案系統則是用
	      <option>ro</option>，後面視需要還可以加其他選項。
	      常見的選項如 <option>noauto</option>
	      是用在不要於開機過程中自動的掛載的檔案系統。
	      其他選項可參閱 &man.mount.8; 說明。</para>
	  </listitem>
	</varlistentry>
          
	<varlistentry>
	  <term><literal>dumpfreq</literal></term>
          
	  <listitem>
	    <para>&man.dump.8; 由此項目決定那些檔案系統需要傾印。
	      如果這格空白則以零為預設值。</para>
	  </listitem>
	</varlistentry>

	<varlistentry>
	  <term><literal>passno</literal></term>

	  <listitem>
            <para>這個項目決定檔案系統檢查的順序。
	      對於要跳過檢查的檔案系統，它們的 <literal>passno</literal>
	      值要設為零。 根檔案系統的 <literal>passno</literal> 值應設為一
	      (因為需要比所有其他的還要先檢查)，而其他的檔案系統的
	      <literal>passno</literal> 值應該要設得比一大。
	      若有多個檔案系統具有相同的 <literal>passno</literal> 值，則
	      &man.fsck.8; 會試著平行地(如果可能的話)檢查這些檔案系統。</para>
         </listitem>
	</varlistentry>
      </variablelist>

      <para>更多關於 <filename>/etc/fstab</filename> 
	檔案格式及選項的資訊請參閱 &man.fstab.5; 說明文件。</para>
    </sect2>

    <sect2 id="disks-mount">
      <title><command>mount</command> 指令</title>
      <indexterm>
	<primary>檔案系統 file systems</primary>
	<secondary>掛載 mounting</secondary>
      </indexterm>
        
      <para>&man.mount.8; 指令是拿來掛載檔案系統用的。</para>
        
      <para>基本的操作指令格式如下:</para>

      <informalexample>
	<screen>&prompt.root; <userinput>mount <replaceable>device</replaceable> <replaceable>mountpoint</replaceable></userinput></screen>
      </informalexample>

      <para>在 &man.mount.8;
	裡面有提到一大堆的選項，不過最常用的就是這些：</para>

      <variablelist>
	<title>掛載選項</title>

	<varlistentry>
	  <term><option>-a</option></term>
            
	  <listitem>
	    <para>把 <filename>/etc/fstab</filename>
	      裡面所有還沒有被掛載、沒有被標記成 <quote>noauto</quote>
	      而且沒有用 <option>-t</option> 排除的檔案系統掛載起來。</para>
	  </listitem>
	</varlistentry>
          
	<varlistentry>
	  <term><option>-d</option></term>
            
	  <listitem>
	    <para>執行所有的動作，但是不真的去呼叫掛載的 system call。
	      這個選項和 <option>-v</option> 搭配拿來推測 &man.mount.8;
	      將要做什麼動作時很好用。</para>
	  </listitem>
	</varlistentry>
          
	<varlistentry>
	  <term><option>-f</option></term>

	  <listitem>
	    <para>強迫掛載不乾淨的檔案系統 (危險)，或是用來強制取消寫入權限
	      (把檔案系統的掛載狀態從可存取變成唯讀)。</para>
	  </listitem>
	</varlistentry>
          
	<varlistentry>
          <term><option>-r</option></term>
            
	  <listitem>
	    <para>用唯讀的方式掛載檔案系統。 這個選項和在 <option>-o</option>
	      選項中指定 <option>ro</option>
	      參數是一樣的。</para>
	  </listitem>
	</varlistentry>
          
	<varlistentry>
	  <term><option>-t</option>
	    <replaceable>fstype</replaceable></term>

	  <listitem>
	    <para>用指定的檔案系統型態 (fstype)
	      來掛載指定的檔案系統，或是在有 <option>-a</option>
	      選項時只掛載指定型態的檔案系統。</para>
              
	    <para>預設的檔案系統是 <quote>ufs</quote>。</para>
	  </listitem>
	</varlistentry>
          
	<varlistentry>
	  <term><option>-u</option></term>
            
	  <listitem>
	    <para>更新檔案系統的掛載選項。</para>
	  </listitem>
	</varlistentry>
          
	<varlistentry>
	  <term><option>-v</option></term>
            
	  <listitem>
	    <para>顯示較詳細資訊。</para>
	  </listitem>
	</varlistentry>
          
	<varlistentry>
	  <term><option>-w</option></term>
            
	  <listitem>
	    <para>以可存取的模式掛載檔案系統。</para>
	  </listitem>
	</varlistentry>
      </variablelist>
        
      <para><option>-o</option> 選項後面會接著以逗號分隔的參數，例如：</para>
      <variablelist>
	<varlistentry>
	  <term>noexec</term>
            
	  <listitem>
	    <para>不允許在這個檔案系統上執行二進位程式碼，
	      這也是一個蠻有用的安全選項。</para>
	  </listitem>
	</varlistentry>
          
	<varlistentry>
	  <term>nosuid</term>
            
	  <listitem>
	    <para>不解析檔案系統上的 setuid 或 setgid 旗標，
	      這也是一個蠻有用的安全選項。</para>
	  </listitem>
	</varlistentry>
      </variablelist>
    </sect2>

    <sect2 id="disks-umount">
      <title><command>umount</command> 指令</title>
      <indexterm>
	<primary>檔案系統 file systems</primary>
	<secondary>卸載 unmounting</secondary>
      </indexterm>
        
	<para>&man.umount.8; 指令的參數可以是掛載點
	  (mountpoint)，裝置名稱，以及 <option>-a</option> 或是
	  <option>-A</option> 等選項。</para>

	<para>加上 <option>-f</option> 可以強制卸載，加上 <option>-v</option>
	  則是會顯示詳細資訊。要注意的是一般來說用 <option>-f</option>
	  並不是個好主意，強制卸載檔案系統有可能會造成電腦當機，
	  或者損壞檔案系統內的資料。</para>
        
	<para><option>-a</option> 和 <option>-A</option>
	  是用來卸載所有已掛載的檔案系統，另外還可以用 <option>-t</option>
	  來指定要卸載的是哪些種類的檔案系統。要注意的是 <option>-A</option>
	  並不會試圖卸載根檔案系統。</para>

    </sect2>
  </sect1>

  <sect1 id="basics-processes">
    <title>程序</title>

    <para>FreeBSD 是一個多工的作業系統，也就是說在同一時間內可以跑超過一個程式。
      每一個正在花時間跑的程式就叫做 <firstterm>程序 (process)</firstterm>。
      您下的每個指令都至少會開啟一個新的程序，
      而有些系統程序是一直在跑以維持系統正常運作的。</para>

    <para>每一個程序都有一個不重覆的數字叫做 <firstterm>process ID
      </firstterm>，或稱為 <firstterm>PID
      </firstterm>，而且就像檔案一樣，每一個程序也有擁有者及群組。
      擁有者及群組的資訊是用來決定什麼檔案或裝置是這個程序可以開啟的
      (前面有提到過檔案權限)。 大部份的程序都有父程序。
      父程序是開啟這個程序的程序，例如：您對 shell 輸入指令，shell
      本身就是一個程序，而您執行的指令也是程序。
      每一個您用這種方式跑的程序的父程序都是 shell。
      有一個特別的程序叫做 &man.init.8; 是個例外。<command>init</command>
      永遠是第一個程序，所以他的 PID 一直都會是 1。 在 FreeBSD 開機的時候
      <command>init</command> 會自動地被 kernel 開啟。</para>
        
    <para>要看系統執行中的程序，有兩個相當有用的指令可用：
      &man.ps.1; 以及 &man.top.1;。<command>ps</command> 
      指令是用來列出正在執行之程序，而且可以顯示它們的
      PID、用了多少記憶體、執行的指令名稱及其後之參數是什麼等等。
      <command>top</command> 指令則是顯示所有正在執行的程序，
      並且數秒鐘更新一次。因此您可以互動式的觀看您的電腦正在做什麼。</para>

    <para>在預設的情況下，<command>ps</command>
      指令只會顯示您所擁有的程序。例如：</para>
        
    <screen>&prompt.user; <userinput>ps</userinput>
  PID  TT  STAT      TIME COMMAND
  298  p0  Ss     0:01.10 tcsh
 7078  p0  S      2:40.88 xemacs mdoc.xsl (xemacs-21.1.14)
37393  p0  I      0:03.11 xemacs freebsd.dsl (xemacs-21.1.14)
48630  p0  S      2:50.89 /usr/local/lib/netscape-linux/navigator-linux-4.77.bi
48730  p0  IW     0:00.00 (dns helper) (navigator-linux-)
72210  p0  R+     0:00.00 ps
  390  p1  Is     0:01.14 tcsh
 7059  p2  Is+    1:36.18 /usr/local/bin/mutt -y
 6688  p3  IWs    0:00.00 tcsh
10735  p4  IWs    0:00.00 tcsh
20256  p5  IWs    0:00.00 tcsh
  262  v0  IWs    0:00.00 -tcsh (tcsh)
  270  v0  IW+    0:00.00 /bin/sh /usr/X11R6/bin/startx -- -bpp 16
  280  v0  IW+    0:00.00 xinit /home/nik/.xinitrc -- -bpp 16
  284  v0  IW     0:00.00 /bin/sh /home/nik/.xinitrc
  285  v0  S      0:38.45 /usr/X11R6/bin/sawfish</screen>

    <para>在這個範例裡可以看到 &man.ps.1; 的輸出分成好幾個欄位。
      <literal>PID</literal> 就是前面有提到的 process ID。 PID 的分配是從
      1 開始一直到 99999，如果用完的話又會繞回來重頭開始分配
      (若該 PID 已經在用了，則 PID 不會重新分配)。
      <literal>TT</literal> 欄位是指這個程式在哪個 tty
      上執行，在這裡可以先忽略不管。<literal>STAT</literal>
      是程式的狀態，也可以先不要管。<literal>TIME</literal> 是這個程式在
      CPU 上執行的時間&mdash;這通常不是程式總共花的時間，
      因為當您開始執行程式後，大部份的程式在 CPU 上執行前會先花上不少時間等待
      。  最後，<literal>COMMAND</literal> 是執行這個程式的命令列。</para>
        
    <para>&man.ps.1;
      有幾個不同的選項組合可以用來變更顯示出來的資訊，其中一個最有用的組合是
      <literal>auxww</literal>。
      <option>a</option> 可以顯示所有正在跑的程序的指令，不只是您自已的。
      <option>u</option> 則是顯示程序的擁有者名稱以及記憶體使用情況。
      <option>x</option> 可以把 daemon 程序顯示出來，
      而 <option>ww</option> 可讓 &man.ps.1; 顯示出每個程序完整的內容，
      而不致因過長而被螢幕截掉了。</para>
        
    <para>&man.top.1; 也有類似的輸出。  一般的情況看像是這樣：</para>

    <screen>&prompt.user; <userinput>top</userinput>
last pid: 72257;  load averages:  0.13,  0.09,  0.03    up 0+13:38:33  22:39:10
47 processes:  1 running, 46 sleeping
CPU states: 12.6% user,  0.0% nice,  7.8% system,  0.0% interrupt, 79.7% idle
Mem: 36M Active, 5256K Inact, 13M Wired, 6312K Cache, 15M Buf, 408K Free
Swap: 256M Total, 38M Used, 217M Free, 15% Inuse

  PID USERNAME PRI NICE  SIZE    RES STATE    TIME   WCPU    CPU COMMAND
72257 nik       28   0  1960K  1044K RUN      0:00 14.86%  1.42% top
 7078 nik        2   0 15280K 10960K select   2:54  0.88%  0.88% xemacs-21.1.14
  281 nik        2   0 18636K  7112K select   5:36  0.73%  0.73% XF86_SVGA
  296 nik        2   0  3240K  1644K select   0:12  0.05%  0.05% xterm
48630 nik        2   0 29816K  9148K select   3:18  0.00%  0.00% navigator-linu
  175 root       2   0   924K   252K select   1:41  0.00%  0.00% syslogd
 7059 nik        2   0  7260K  4644K poll     1:38  0.00%  0.00% mutt
...</screen>

    <para>輸出的資訊分成兩個部份。開頭 (前五行) 秀出最近一個程序的
      PID、系統平均負載 (系統有多忙錄的測試)、系統的開機時間
      (從上次重開算起) 以及現在的時間等。
      在開頭裡面的其他數字分別是在講有多少程序正在執行
      (在本例中為47)、有多少記憶體及 swap space
      被占用了，還有就是系統分別花了多少時間在不同的 CPU 狀態上。</para>

    <para>接下來的部份是由好幾個欄位所構成，和 &man.ps.1; 輸出的資訊類似。
      就如同前例，您可以看到 PID、使用者名稱、CPU
      花費的時間以及正在執行的指令。 &man.top.1;
      在預設的情況下還會告訴您程序用掉了多少的記憶體空間。
      在這邊會分成兩欄，一個是總用量 (total size)，另一個是實際用量
      (resident size)&mdash;總用量是指這個應用程式需要的記憶體空間，
      而實際用量則是指實際上該程式的記憶體使用量。
      在這個例子裡面您可以看到 <application>&netscape;</application>
      要了幾乎到 30 MB 的 RAM，但是只有用到 9 MB。</para>
    
    <para>&man.top.1; 每隔 2 秒鐘會自動更新顯示內容，可用 <option>s</option>
      選項來改變間隔的時間。</para>
    
  </sect1>

  <sect1 id="basics-daemons">
    <title>Daemon、信號及終止程序</title>

    <para>當在執行文書編輯器時，您可以很容易地使用它，叫它讀取檔案或是什麼的。
      可以這樣做是因為編輯器有提供這些功能，
      還有就是編輯器依附在一個<firstterm>終端機 (Terminal) </firstterm>之上。
      有些程式並不是設計成一直在接收使用者的輸入的，
      所以它們在一開始執行的時候就從終端機斷開了。 例如說，
      網頁伺服器整天都在回應網頁方面的要求，它通常不需要您輸入任何東西。 
      另外，像是把信從一個站傳送到另一個站的程式，也是這種類型的應用程式。
      </para>
        
    <para>我們把這種程式稱作 <firstterm>daemon</firstterm>。
      Daemon (惡魔、守護神)
      是希臘神話中的角色：祂們不屬於善良陣營或邪惡陣營，是守護的小精靈。
      大致上來說祂們就是在替人類做一些有用的事情，
      跟今天的網頁伺服器或是郵件伺服器很像。  這也就是為何 BSD
      的吉祥物，長期以來都是一隻穿著帆布鞋拿著三叉耙的快樂小惡魔的原因。</para>

    <para>通常來說 deamon 程式的名字後面都會加一個字母 <quote>d</quote>。
      <application>BIND</application> 是 Berkeley Internet Name Domain
      的縮寫 (但實際上執行的程式名稱是 <command>named</command>)、Apache
      網頁伺服器的程式名稱是 <command>httpd</command>、印表機服務程式是
      <command>lpd</command>，依此類推。
      這是習慣用法，並沒有硬性規定，例如 <application>Sendmail</application>
      主要的寄信 daemon 是叫做 <command>sendmail</command> 而不是
      <command>maild</command>，跟您想像的不一樣。</para>

    <para>有些時候會需要跟某個 daemon 程序溝通，
      這些溝通是透過所謂的<firstterm>信號(signal)</firstterm>來傳遞給該 daemon
      程序(或是其他執行中的程序)。
      藉由送出信號，您可以和一個 daemon (或是任何一個正在跑的程序) 溝通。
      信號有很多種&mdash;有些有特定的意義，有些則是會由應用程式來解讀。
      應用程式的說明文件會告訴您該程式是如何解讀信號的。
      您只能送信號給您擁有的程序，送 &man.kill.1; 或 &man.kill.2;
      的信號給別人的程序是不被允許的。 不過 <username> root </username>
      不受此限制，他可以送信號給任何人的程序。</para>

    <para>FreeBSD 本身在某些情況也會送信號給應用程式。
      假設有個應用程式寫得很爛，然後企圖要存取它不該碰的記憶體的時候，FreeBSD
      會送一個 <firstterm>Segmentation Violation</firstterm> 信號
      (<literal>SIGSEGV</literal>) 給這個程序。
      又如果有一個應用程式用了 &man.alarm.3; 的 system call
      要求系統在過一段時間之後叫他一下，時間到了的時候鬧鐘的信號
      (<literal>SIGALRM</literal>) 就會被送出了，其他的依此類推。</para>

    <para><literal>SIGTERM</literal> and <literal>SIGKILL</literal>
      這兩個信號可以拿來終止程序。 用 <literal>SIGTERM</literal>
      結束程序是比較有禮貌的方式，該程序會<emphasis>捕捉 (catch) </emphasis>
      這個信號而了解到您想要把他關掉。 接著下來它會把它自已開的記錄檔通通關掉，
      然後在關掉程序之前結束掉手邊的工作。 在某些情況下程序有可能會裝作沒看見
      <literal>SIGTERM</literal>，假如它正在做一些不能中斷的工作的話。</para>

    <para><literal>SIGKILL</literal> 就沒有辦法被程序忽略了。
      這是一個<quote>我管你正在幹嘛，現在就給我停下來</quote>的信號。
      如果您送了 <literal>SIGKILL</literal> 信號給某個程序，FreeBSD
      將會把它停掉<footnote>
	<para>不完全正確&mdash;還是有少數東西不能被中斷。
	  例如有個程序正在從網路上的別的電腦讀一個檔案，
	  而那部電腦因為某些理由連不到 (機器被關掉，或是網路爛掉了)，
	  那這個程序我們就說他是一個<quote>不能中斷的</quote>程序。
	  通常在經過兩分鐘左右之後這個程序會逾時。
	  當發生逾時的時候這個程序就會被結束掉了。</para>
      </footnote>。</para>
    
    <para>這些是其他您有可能會要用到的信號：
      <literal>SIGHUP</literal>，<literal>SIGUSR1</literal>，以及
      <literal>SIGUSR2</literal>。
      這些是通用的信號，當送出時不同的應用程式會有不同的反應。</para>
      
    <para>假設您更動了您的網頁伺服器的設定檔&mdash;
      您想要叫網頁伺服器去重新讀取設定值。 您可以關閉後再重新啟動
      <command>httpd</command>，但是這麼做會造成網頁伺服器暫停服務一段時間，
      這樣子可能不太好。
      大部份的 daemon 都寫成會去回應 <literal>SIGHUP</literal>。
      當收到這個信號之後，它們會去重新讀取自已的設定檔。
      因此您可以用送 <literal>SIGHUP</literal> 信號來取代關掉重開。
      又因為沒有標準在規範如何回應這些信號，不同的 daemon
      可能會有不同的行為，所以有疑問的話請先確認並翻閱 deamon
      的說明文件。</para>
    
    <para>信號是由 &man.kill.1; 指令送出的，如範例所示：</para>
    
    <procedure>
      <title>送信號給程序</title>

      <para>這個範例將會示範如何送一個信號給 &man.inetd.8;。
        <command>inetd</command> 的設定檔是
        <filename>/etc/inetd.conf</filename>，而 <command>inetd</command>
        會在收到 <literal>SIGHUP</literal> 的時候重新讀取這個設定檔。</para>

      <step>
        <para>找出您想要送信號的那個程序的 ID。 您會用到 &man.ps.1; 以及
          &man.grep.1; 這兩個指令。  &man.grep.1; 是用來在輸出中搜尋，
	  找出您指定的字串。  這個指令是由一般使用者執行，而 &man.inetd.8;
          是由 <username>root</username> 執行，所以在使用 &man.ps.1; 時需要加上
	  <option>ax</option> 選項。</para>

        <screen>&prompt.user; <userinput>ps -ax | grep inetd</userinput>
  198  ??  IWs    0:00.00 inetd -wW</screen>

        <para>因此可知 &man.inetd.8; 的 PID 為 198。  在某些情況下
	  <literal>grep inetd</literal> 這個指令本身也會出現在輸出裡。
          這是因為 &man.ps.1; 乃是找所有執行中的程序的方式造成的。</para>
      </step>

      <step>
        <para>用 &man.kill.1; 來送信號。 又因為 &man.inetd.8; 是由
	  <username>root</username> 執行的，您必須用 &man.su.1; 切換成
          <username>root</username>先。</para>

	<screen>&prompt.user; <userinput>su</userinput>
<prompt>Password:</prompt>
&prompt.root; <userinput>/bin/kill -s HUP 198</userinput></screen>

        <para>一般情況對大多數 &unix; 指令來講，當 &man.kill.1;
	  執行成功時並不會輸出任何訊息。
	  假設您送一個信號給某個不是您所擁有的程序，
	  那麼您就會吃到這個錯誤訊息： <errorname>kill:
	  <replaceable>PID</replaceable>: Operation not permitted</errorname>。
	  而如果您打錯 PID 的話，那就會把信號送給錯誤的程序。 這樣可能會很糟，
	  不過如果您夠幸運的話，可能剛好就只是把信號送給一個非使用中的
	  PID，那您就只會看到 <errorname>kill:
	  <replaceable>PID</replaceable>: No such process</errorname> 而已。
	  </para>

	<note>
	  <title>為什麼用 <command>/bin/kill</command>？</title>
      
          <para>很多 shell 有提供內建的 <command>kill</command> 指令。
	    也就是說這種 shell 會直接送信號，而不是執行
	    <filename>/bin/kill</filename>。
	    這樣是蠻方便的沒錯啦，但是不同的 shell
	    會有不同的語法來指定信號的名稱等。
	    與其嘗試去把它們通通學會，不如就單純的直接用 <command>/bin/kill
	    <replaceable>...</replaceable></command> 吧。</para>
	</note>
      </step>
    </procedure>

    <para>要送其他的信號的話也是非常類似，就視需要把指令中的
      <literal>TERM</literal> 或 <literal>KILL</literal>
      替換掉即可。</para>
    
    <important>
      <para>隨便抓一個系統中的程序然後把他砍掉並不是個好主意。
        特別是 &man.init.8;， process ID 1，一個非常特別的程序。
        執行 <command>/bin/kill -s KILL 1</command>
        的結果就是系統立刻關機。 因此在您按下 <keycap>Return</keycap>
        要執行 &man.kill.1;<emphasis>之前</emphasis>，
        請<emphasis>一定</emphasis>要記得再次確認您下的參數。</para>
    </important>
  </sect1>

  <sect1 id="shells">
    <title>Shells</title>
    <indexterm><primary>shells</primary></indexterm>
    <indexterm><primary>命令列 command line</primary></indexterm>

    <para>在 FreeBSD 中，很多日常的工作是在一個叫做 shell
      的文字介面中完成的。  
      Shell 的主要工作就是從輸入中收到命令並執行它們。
      許多 shell 也有內建一些有助於日常工作的指令，
      像是檔案管理、檔案比對、命令列編輯、指令巨集以及環境變數等。
      FreeBSD 有內附了幾個 shell，像是 <command>sh</command>，
      Bourne Shell，以及 <command>tcsh</command>，改良版的 C-shell。
      還有許多其他的 shell 可以從 FreeBSD Ports Collection 
      中取得，像是 <command>zsh</command> 以及 <command>bash</command>
      等。</para>

    <para>您用哪個 shell 呢？ 其實每個人的喜好都不一樣。
      如果您是一個 C 程式設計師，那對於使用像是 <command>tcsh</command>
      這種 C-like 的 shell 可能會感到相當愉快。如果您是從 Linux
      跳過來的，或者您是一個 &unix; 新手，那您也許會想要用
      <command>bash</command> 來當作文字介面。
      每一個 shell 都有自已獨特之處，至於這些特點能不能配合您的工作環境？
      那就是您選擇 shell 的重點了。</para>

    <para>檔名自動補齊就是常見的 shell 功能。
      首先輸入指令或檔案的前幾個字母，這時通常您只需要按下 <keycap>Tab</keycap>
      鍵，接下來 shell 就會自動把指令或是檔案名稱剩餘的部份補齊。
      假設您有兩個檔案分別叫作 <filename>foobar</filename> 及
      <filename>foo.bar</filename>。  現在要刪掉 
      <filename>foo.bar</filename>，那麼可以輸入：
      <command>rm fo[<keycap>Tab</keycap>].[<keycap>Tab</keycap>]</command>
      </para>
    
    <para>Shell 會印出這個： <command>rm foo[嗶].bar</command>。</para>
    
    <para>[嗶] 是 console 的響鈴，這嗶的一聲是 shell
      在告訴我說它沒有辦法完全自動補齊檔名，因為有不只一個檔名符合條件。
      <filename>foobar</filename> 和 <filename>foo.bar</filename> 都是
      <literal>fo</literal> 開頭的檔名，不過它至少可以補齊到 <literal>foo</literal>。
      如果您接著輸入 <literal>.</literal> 然後再按 <keycap>Tab</keycap>
      一次，那 shell 就能夠替您把剩下的檔名填滿了。</para>
    
    <indexterm><primary>environment variables</primary></indexterm>

    <para>Shell 的另一項特點是使用了環境變數。
      環境變數是以變數與鍵值（variable/key）的對應關係儲存於 shell 
      的環境空間中，任何由 shell 所產生的程序都可以讀取此空間，
      因此這個空間儲存了許多程序的設定組態。  在此附上
      一份常見環境變數與其涵義的列表：</para>
    <indexterm><primary>environment variables</primary></indexterm>

    <informaltable frame="none" pgwide="1">
      <tgroup cols="2">
	<thead>
	  <row>
	    <entry>變數</entry>
	    <entry>詳細說明</entry>
	  </row>
	</thead>

	<tbody>
	  <row>
	    <entry><envar>USER</envar></entry>
	    <entry>目前登入的使用者名稱。</entry>
	  </row>

	  <row>
	    <entry><envar>PATH</envar></entry>
	    <entry>以冒號（:）隔開的目錄列表，用以搜尋執行檔的路徑。</entry>
	  </row>

	  <row>
	    <entry><envar>DISPLAY</envar></entry>
	    <entry>若存在這個環境變數，則代表 X11 連結顯示器的網路名稱。</entry>
	  </row>

	  <row>
	    <entry><envar>SHELL</envar></entry>
	    <entry>目前使用的 shell。</entry>
	  </row>

	  <row>
	    <entry><envar>TERM</envar></entry>
	    <entry>使用者終端機的名稱，能藉由此變數判斷終端機的能力。</entry>
	  </row>

	  <row>
	    <entry><envar>TERMCAP</envar></entry>
	    <entry>表現各種終端機功能的跳脫代碼 (escape code) 資料庫項目。</entry>
	  </row>

	  <row>
	    <entry><envar>OSTYPE</envar></entry>
	    <entry>作業系統的種類，如：FreeBSD。</entry>
	  </row>

	  <row>
	    <entry><envar>MACHTYPE</envar></entry>
	    <entry>目前系統所用的 CPU 架構。</entry>
	  </row>

	  <row>
	    <entry><envar>EDITOR</envar></entry>
	    <entry>使用者偏好的文字編輯器。</entry>
	  </row>

	  <row>
	    <entry><envar>PAGER</envar></entry>
	    <entry>使用者偏好的文字分頁器（text pager）。</entry>
	  </row>

	  <row>
	    <entry><envar>MANPATH</envar></entry>
	    <entry>以冒號（:）隔開的目錄列表，用以搜尋 manual pages 的路徑。</entry>
	  </row>
	</tbody>
      </tgroup>
    </informaltable>

    <indexterm><primary>Bourne shells</primary></indexterm>
    <para>在不同的 shell 底下設定環境變數的方式也有所不同。
      舉例來說，在 C-Style 的 shell 底下，像是
      <command>tcsh</command> 和 <command>csh</command>，您必須使用
      <command>setenv</command> 來設定環境變數。
      但在 Bourne shells 底下，像是 <command>sh</command> 和
      <command>bash</command>，你則必須使用 
      <command>export</command> 來設定你所使用的環境變數。
      再舉個例子來說，若要設定或是修改
      <envar>EDITOR</envar> 這個環境變數，在 <command>csh</command> 或 
      <command>tcsh</command> 下設定 <envar>EDITOR</envar> 這個環境變數為 
      <filename>/usr/local/bin/emacs</filename> 的指令是：</para>

    <screen>&prompt.user; <userinput>setenv EDITOR /usr/local/bin/emacs</userinput></screen>

    <para>在 Bourne shells 下則是：</para>

    <screen>&prompt.user; <userinput>export EDITOR="/usr/local/bin/emacs"</userinput></screen>

    <para>大多數的 shell 都支援使用者在命令列中將 
      <literal>$</literal> 字元放在變數之前，以取得環境變數的值。
      舉例來說，<command>echo $TERM</command> 會
      顯示出 <envar>$TERM</envar> 的設定值，這是因為 shell 取得了 
      <envar>$TERM</envar> 的設定值，
      並將其傳給 <command>echo</command> 顯示出來。</para>

    <para>Shell 中有某些特別的字元是來表示特殊的資料，我們將其稱作
      meta-characters。  其中最常見的是 
      <literal>*</literal> 字元，他代表了檔名中的任意字元。
      這些特殊字元可以用在檔名展開（filename globbing）上，舉例來說，輸入 
      <command>echo *</command> 會和輸入 
      <command>ls</command> 得到幾乎相同的結果，這是因為 shell 會將所有符合 
      <literal>*</literal> 字元的檔案傳到命令列上，再由 
      <command>echo</command> 顯示出來。</para>

    <para>為了避免 shell 轉譯這些特殊字元，我們可以在這些特殊字元前放一個反斜線
      (<literal>\</literal>) 字元使他們跳脫(escape) shell 的轉譯。舉例來說，
      <command>echo $TERM</command> 會印出你目前設定的終端機格式，
      <command>echo \$TERM</command> 則會直接印出 <envar>$TERM</envar> 
      這幾個字。</para>

    <sect2 id="changing-shells">
      <title>變更你的 Shell</title>

      <para>變更 shell 最簡單的方法就是透過 <command>chsh</command> 命令。 
        執行 <command>chsh</command> 將會呼叫環境變數中 <envar>EDITOR</envar>
	指定的文字編輯器。如果沒有設定，則預設是 <command>vi</command>。
	請依照需求去修改 <quote>Shell:</quote> 的值。

      <para>你也可以透過 <command>chsh</command> 的參數 <option>-s</option>，
	這可以直接設定你的 shell 而不需要透過任何文字編輯器。  例如，
	假設想把所用的 shell 改為 <command>bash</command>，
	可以透過下列的方式：</para>

      <screen>&prompt.user; <userinput>chsh -s /usr/local/bin/bash</userinput></screen>

      <note>
	<para>你所使用的 shell <emphasis>必須</emphasis> 列於
	  <filename>/etc/shells</filename> 裡頭。  如果是由 
	  <link linkend="ports">Ports Collection</link> 來裝 shell，
	  那這個步驟已經完成了。但若是手動安裝了一個 shell，
	  那麼就必須為新安裝的 shell 進行設定。</para>
     
      <para>舉例來說，若手動安裝了 <command>bash</command> 並將它置於
	  <filename>/usr/local/bin</filename> 底下，你還得：</para>

      <screen>&prompt.root; <userinput>echo &quot;/usr/local/bin/bash&quot; &gt;&gt; /etc/shells</userinput></screen>

       <para>然後再重新執行 <command>chsh</command>。</para>
     </note>
   </sect2>
  </sect1>

  <sect1 id="editors">
    <title>文字編輯器</title>
    <indexterm><primary>text editors</primary></indexterm>
    <indexterm><primary>editors</primary></indexterm>

    <para>在 FreeBSD 中有許多設定必須透過編輯文字檔完成。
      因此，若能熟悉文字編輯器是再好不過的。
      FreeBSD 本身（指 base system）就附有幾種文字編輯器，
      此外，你也可以透過 Ports Collection 來安裝其他的文字編輯器。</para>

    <indexterm>
      <primary><command>ee</command></primary>
    </indexterm>
    <indexterm>
      <primary>editors</primary>
      <secondary><command>ee</command></secondary>
    </indexterm>
    <para>最簡單易學的文字編輯器叫做 <application>ee</application>，
      代表了其全名 easy editor。要開始使用 <application>ee</application>，
      必須在命令列上輸入
      <command>ee <replaceable>filename</replaceable></command>，
      這邊的 <replaceable>filename</replaceable> 代表你想要編輯的檔案名稱。
      舉例來說，要編輯 <filename>/etc/rc.conf</filename>，就要輸入
      <command>ee /etc/rc.conf</command>。
      而在 <command>ee</command> 的操作介面下，
      所有編輯器的功能與操作都會顯示在螢幕的正上方。
      其中的插入符號(<literal>^</literal>)代表鍵盤上的 <keycap>Ctrl</keycap>
      鍵，所以 <literal>^e</literal> 就等同於
      <keycombo action="simul"><keycap>Ctrl</keycap><keycap>e</keycap></keycombo>
      。若要結束 <application>ee</application>，請按下 <keycap>Esc</keycap>
      鍵，接著選擇 leave editor 即可。
      此時如果該檔案有修改過，編輯器會提醒你是否要存檔。</para>

    <indexterm>
      <primary><command>vi</command></primary>
    </indexterm>
    <indexterm>
      <primary>editors</primary>
      <secondary><command>vi</command></secondary>
    </indexterm>
    <indexterm>
      <primary><command>emacs</command></primary>
    </indexterm>
    <indexterm>
      <primary>editors</primary>
      <secondary><command>emacs</command></secondary>
    </indexterm>

    <para>此外，FreeBSD 也內附了幾個好用的文字編輯器，像是 base system 的
      <application>vi</application> 及 FreeBSD Ports Collection 內的其他編輯器，
      比如 <application>Emacs</application> 及 <application>vim</application>
      (<filename role="package">editors/emacs</filename> 及
      <filename role="package">editors/vim</filename>)。
      這些文字編輯器提供更強的功能，但是也比較難學習。
      然而若要從事大量文字編輯工作，
      那麼花點時間來學習這些好用的編輯器，
      會在日後為您省下更多的時間。</para>

    <para>許多應用軟體修改檔案或需要打字輸入時會自動開啟文字編輯器。
      要更改預設編輯器，可設定 <envar>EDITOR</envar> 環境變數。
      欲知詳情參見 <link linkend="shells">shells</link> 一節。</para>
  </sect1>

  <sect1 id="basics-devices">
    <title>設備及設備節點</title>

    <para>設備(device)主要是指跟硬體比較有關的術語，
      包括磁碟、印表機、顯示卡和鍵盤。  FreeBSD 開機過程當中，
      大多數硬體通常都能偵測到並顯示出來，也可以查閱
      <filename>/var/run/dmesg.boot</filename> 內有開機的相關訊息。</para>

    <para>舉例來說，<devicename>acd0</devicename>即為第一台 IDE 光碟機的代號，
      而 <devicename>kbd0</devicename> 則代表鍵盤。</para>

    <para>在 &unix; 作業系統，
      大部分的設備都是透過叫做 device nodes(設備節點)的特殊檔案來作存取，
      而這些檔案都位於 <filename>/dev</filename> 目錄。</para>

    <sect2>
      <title>建立設備節點</title>
      <para>若要在系統上建立新節點，或者是要編譯某些新硬體的支援軟體，
	那麼就要先新增設備節點。</para>

      <sect3>
	<title><literal>DEVFS</literal> (DEVice File System)</title>

	<para>設備檔案系統(或稱為 <literal>DEVFS</literal>) 是指在整體檔案系統
	  namespace 提供 kernel 的設備 namespace。<literal>DEVFS</literal>
	  乃是維護這些檔案系統，而不能新增或修改這些設備節點。</para>

	<para>細節請參閱 &man.devfs.5; 說明。</para>
      </sect3>
    </sect2>
  </sect1>

  <sect1 id="binary-formats">
    <title>Binary 格式</title>

    <para>要瞭解為何 &os; 採用 &man.elf.5; 格式，必先稍懂當前 &unix;
      中三種<quote>最主要的</quote>可執行檔格式：</para>

    <itemizedlist> 
      <listitem>
        <para>&man.a.out.5;</para>

        <para>最古老的<quote>典型</quote> &unix; object 格式，
	  使用由魔術數字 (magic number) 開頭的簡短 header，該數字往往
	  標示格式的特性（詳情請見 &man.a.out.5;）。此格式包含了三個
	  要載入記憶體的區段 (segment)：.text、.data、.bss，外加符號表
	  (symbol table) 及字串表 (string table)。</para>
      </listitem>

      <listitem>
        <para><acronym>COFF</acronym></para>

        <para>SVR3 object 格式。現在 header 包含了區段表
	  (section table), 因此除了 .text、.data、.bss
	  外還能有更多的區段。</para>
      </listitem>

      <listitem>
        <para>&man.elf.5;</para>

        <para><acronym>COFF</acronym> 的繼承者，特色是多重區段，
	  甚至可用到 32 位元或 64 位元的數值。主要的缺陷是：
	  <acronym>ELF</acronym> 設計時也假定每個系統架構只有一個
	  ABI (Application binary interface)。這假設大錯特錯，甚至在商業的
	  SYSV 世界 (SVR4、Solaris、SCO 都至少有三個 ABI) 都無法成立。</para>

        <para>FreeBSD 試圖稍微解決這個問題，作法是提供可將已知的
	  <acronym>ELF</acronym> 檔<emphasis>標示</emphasis>上
	  相容的 ABI 資訊以便執行的工具。詳情可參見
	  &man.brandelf.1; 的 manual page。</para>
      </listitem>
    </itemizedlist>

    <para>FreeBSD 來自<quote>古典派的</quote>陣營，在 3.X 分支開始前是使用
      &man.a.out.5; 這個通過許多 BSD 發行世代技術考驗所保證的格式。
      雖然在那之前一段時間，FreeBSD 系統上就有辦法運行原生 (native) 的
      <acronym>ELF</acronym> binary（以及核心），但 FreeBSD
      一開始抗拒<quote>推動</quote>將預設格式改為
      <acronym>ELF</acronym>。原因為何？來看 Linux 陣營歷經千辛萬苦轉換成
      <acronym>ELF</acronym> 後，還是無法拋棄因有著基於 jump-table
      而毫無彈性的共享函式庫機制，造成廠商及開發者等建構共享函式庫時極度困難的
      <filename>a.out</filename> 執行格式。
      自從有了能解決共享記憶體問題且普遍看來算是<quote>進步</quote>的
      <acronym>ELF</acronym> 工具，大家才同意真有轉換的價值進而實行。
      FreeBSD 的共享記憶體機制比較接近 Sun 的 &sunos; 風格，一樣非常容易使用。</para>

    <para>那為何有這麼多不同的格式？</para>

    <para>回到那黑暗的過去來看吧，那時只有簡單的硬體，
      這種簡單的硬體就支援簡單的小型系統。在這種小型系統 (PDP-11) 上
      <filename>a.out</filename> 就完全足以表達 binary 。當 &unix;
      從這種小型系統移植出去時，因為在早期移植到像 Motorola 68k、VAXen
      等架構的 &unix; 上 <filename>a.out</filename>
      格式就夠用了，得以保留下來。</para>

    <para>後來有點聰明的硬體工程師判斷若能強迫軟體運用點小技巧，
      就能在設計中去掉一些閘 (gate) 讓處理器核心加快運行。然而依此作出了新款硬體
      （現在叫 <acronym>RISC</acronym>）後，<filename>a.out</filename>
      卻不適用，為了突破簡單的 <filename>a.out</filename> 格式造成的限制
      讓此硬體發揮更高的效能，於是開發了眾多格式。像 <acronym>COFF</acronym>、
      <acronym>ECOFF</acronym> 及一些其他沒沒無名的格式相繼發明，但各有新的侷限，
      似乎到了 <acronym>ELF</acronym> 出現才解決問題。</para>

    <para>另外，程式大小逐漸增長但磁碟（及實體記憶體）相對上仍然很小，
      因此產生了共享函式庫的概念。虛擬機器 (VM) 系統也變得更複雜。
      當利用 <filename>a.out</filename> 格式完成這兩個改良時，
      它也竭盡所能用在每個新功能上。接著大家想在執行時期 (run time) 動態載入，
      或是在初始化程式碼 (init code) 執行後捨棄程式部分內容以便存在核心記憶體及
      swap 空間。程式語言更是高度發展，大家想在 main 之前就先呼叫程式碼。
      為了達成這些功能，<filename>a.out</filename> 格式作了大量改造，
      且一度達到基本要求。這時 <filename>a.out</filename> 的 code 及
      複雜度必須不斷擴張才能處理這所有的問題。即使 <acronym>ELF</acronym>
      解決了大部份的問題，要從運作基本功能的系統切換過去還是很辛苦。所以
      <acronym>ELF</acronym> 得等到當延用 <filename>a.out</filename> 
      比轉移到 <acronym>ELF</acronym> 還累時才行。</para>

    <para>然而隨著時光流逝, FreeBSD 使用的程式編寫工具 ( build
      tool) 的來源（特別是組譯器和 loader）在兩條路上平行發展。FreeBSD
      路線增加了共享函式庫及修正一些 bug。原本撰寫這些程式的 GNU 成員們
      又重寫它們，並對編寫跨平臺編譯器、任意外掛不同格式、其他等等增加了更簡易的支援。
      雖然很多人都想編寫針對 FreeBSD 使用的跨平臺編譯器，可惜因為
      FreeBSD 上 <application>as</application> 及 <application>ld</application>
      的原始碼比較舊而無法辦到。新的 GNU tools chain (<application>binutils</application>)
      就支援了跨平臺編譯、<acronym>ELF</acronym>、共享函式庫、C++ extensions
      等等。再說，許多廠商釋出的是 <acronym>ELF</acronym> binary，FreeBSD
      能執行當然是好事。</para>

    <para><acronym>ELF</acronym> 比 <filename>a.out</filename> 表達的資訊更多，
      讓基本系統更好擴充。<acronym>ELF</acronym> 的工具比較好維護，
      且提供對許多人很重要的跨平臺編譯支援。
      <acronym>ELF</acronym> 可能比 <filename>a.out</filename> 稍慢，
      但很難算出到底慢多少。這兩者在對應分頁 (page) 、處理初始化程式碼等等時的許多細節也不同。
      這些事情都不太重要，但畢竟有所不同。適時 <filename>GENERIC</filename> 核心將不支援
      <filename>a.out</filename>，且一旦不再需要執行代代相傳的 <filename>a.out</filename>
      程式，核心終將不再支援。</para>
  </sect1>

  <sect1 id="basics-more-information">
    <title>更多資訊</title>

    <sect2 id="basics-man">
      <title>Manual 線上說明</title>
      <indexterm><primary>manual pages</primary></indexterm>

      <para>在使用 FreeBSD 時，最詳細的使用說明莫過於 man 線上說明。
	幾乎各程式都會有附上簡短說明，以介紹該程式的基本功能跟相關參數用法。
	可以透過 <command>man</command> 指令來閱讀這些說明，而
	<command>man</command> 指令的使用相當簡單易懂：</para>

      <screen>&prompt.user; <userinput>man <replaceable>command</replaceable></userinput></screen>

      <para><literal>command</literal> 處就是想要知道的指令。例如想知道
	<command>ls</command> 的詳細用法就打：</para>

      <screen>&prompt.user; <userinput>man ls</userinput></screen>

      <para>而各線上說明因為性質不同，而區分為下列的數字章節：</para>

      <orderedlist>
	<listitem>
	  <para>使用者指令。</para>
	</listitem>

	<listitem>
	  <para>系統呼叫 (System call) 及錯誤代號。</para>
	</listitem>

	<listitem>
	  <para>C 語言函式庫。</para>
	</listitem>

	<listitem>
	  <para>各設備的驅動程式。</para>
	</listitem>

	<listitem>
	  <para>檔案格式。</para>
	</listitem>

	<listitem>
	  <para>小遊戲程式及其他娛樂程式。</para>
	</listitem>

	<listitem>
	  <para>雜項工具、其他資訊。</para>
	</listitem>

	<listitem>
	  <para>系統維護、操作的指令。</para>
	</listitem>

	<listitem>
	  <para>Kernel 開發用途。</para>
	</listitem>
      </orderedlist>

      <para>有些情況會有同樣主題但不同章節。舉個例子，系統內會有
	<command>chmod</command> 指令，但也有 <function>chmod()</function>
	系統呼叫。在這種情況，<command>man</command>
	應該要指定所要查詢的章節：</para>

      <screen>&prompt.user; <userinput>man 1 chmod</userinput></screen>

      <para>如此一來就會查 <command>chmod</command> 指令部分。
	通常在寫文件時會把有參考到某特定章節的 man 號碼也一併寫在括號內。
	所以 &man.chmod.1; 就是指 <command>chmod</command> 指令，而
	&man.chmod.2; 則是指系統呼叫的部分。</para>

      <para>如果您已經知道命令的名稱，只是不知道要怎樣使用的話，那就比較好辦。
	但若不知道要用哪個指令時，該怎麼辦呢？這個時候，就可以利用
	<command>man</command> 的搜尋關鍵字功能，
	以在各說明的介紹部分搜尋相關字眼。，它的選項是 <option>-k</option>：
	</para>

      <screen>&prompt.user; <userinput>man -k mail</userinput></screen>

      <para>如此一來會看到一堆有 <quote>mail</quote> 關鍵字的說明，
	事實上該功能與 <command>apropos</command> 指令是一樣的。</para>

      <para>而有時你會看到像是 <filename>/usr/bin</filename>
	有許多看起來頗炫的指令，但不知其用途？只要簡單輸入：</para>

	<screen>&prompt.user; <userinput>cd /usr/bin</userinput>
&prompt.user; <userinput>man -f *</userinput></screen>

	<para>或者是</para>

	<screen>&prompt.user; <userinput>cd /usr/bin</userinput>
&prompt.user; <userinput>whatis *</userinput></screen>

	<para>這兩者的指令效果是一樣的。</para>
    </sect2>

    <sect2 id="basics-info">
      <title>GNU Info 檔案</title>
      <indexterm><primary>Free Software Foundation</primary></indexterm>

      <para>FreeBSD 有許多程式跟工具來自於自由軟體基金會(FSF)。除了 man
	線上說明之外，這些程式提供了另外一種更具有彈性的 hypertext 格式文件，
	叫做 <literal>info</literal>。可以用 <command>info</command>
	指令來閱讀，或者若有裝 <application>emacs</application> 亦可透過
	<application>emacs</application> 的 info 模式閱讀。</para>

      <para>要用 &man.info.1; 指令，只需打：</para>

      <screen>&prompt.user; <userinput>info</userinput></screen>

      <para>按 <literal>h</literal> 會有簡單說明，而若要快速查閱相關操作方式，
	則請按 <literal>?</literal>。</para>
    </sect2>
  </sect1>
</chapter>
<!-- 
     Local Variables:
     mode: sgml
     sgml-declaration: "../chapter.decl"
     sgml-indent-data: t
     sgml-omittag: nil
     sgml-always-quote-attributes: t
     sgml-parent-document: ("../book.sgml" "part" "chapter")
     End:
-->
